

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>moments.Spectrum_mod &mdash; moments 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            moments
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SFS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sfs/sfs.html">The Site Frequency Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sfs/parsing.html">Parsing the SFS from a VCF file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sfs/inference.html">SFS Inference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Linkage disequilibrium</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ld/ld.html">Multi-population LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ld/parsing.html">Parsing LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ld/inference.html">Inferring demography with LD</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../extensions/demes.html">Specifying models with <code class="docutils literal notranslate"><span class="pre">demes</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extensions/two_locus.html">Two-locus frequency spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extensions/triallele.html">Triallele frequency spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/diversity.html">Demography and genetic diversity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dfe.html">DFE inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/recombination.html">Linkage disequilibrium and recombination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/two_locus_selection.html">Selection at two loci</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data types and functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/api_moments.html">API for site frequency spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api_ld.html">API for linkage disequilibrium</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api_demes.html">API for <code class="docutils literal notranslate"><span class="pre">demes</span></code> functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">moments</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">moments.Spectrum_mod</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for moments.Spectrum_mod</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains Spectrum object, which represents frequency spectra.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Spectrum_mod&quot;</span><span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">newaxis</span> <span class="k">as</span> <span class="n">nuax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">demes</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">moments.Integration</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">moments.Integration_nomig</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">Numerics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parsing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">moments.Demes.Demes</span>

<span class="n">_plotting</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">moments.ModelPlot</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># if matplotlib is not present, do not import, and do not run plotting functions</span>
    <span class="n">_plotting</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="Spectrum">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Spectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a single-locus biallelic frequency spectrum.</span>

<span class="sd">    Spectra are represented by masked arrays. The masking allows us to ignore</span>
<span class="sd">    specific entries in the spectrum. When simulating under the standard infinite</span>
<span class="sd">    sites model (ISM), the entries we mask are the bins specifying absent or fixed</span>
<span class="sd">    variants. When using a reversible mutation model (i.e. the finite genome model),</span>
<span class="sd">    we track the density of variants in fixed bins, setting ``mask_corners`` to</span>
<span class="sd">    ``False``.</span>

<span class="sd">    :param data: An array with dimension equal to the number of populations.</span>
<span class="sd">        Each dimension has length :math:`n_i+1`, where :math:`n_i` is the</span>
<span class="sd">        sample size for the i-th population.</span>
<span class="sd">    :type data: array</span>
<span class="sd">    :param mask: An optional array of the same size as data. &#39;True&#39; entries in</span>
<span class="sd">        this array are masked in the Spectrum. These represent missing</span>
<span class="sd">        data categories. (For example, you may not trust your singleton</span>
<span class="sd">        SNP calling.)</span>
<span class="sd">    :type maks: array, optional</span>
<span class="sd">    :param mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed</span>
<span class="sd">        in all&#39; entries of the FS will be masked. Typically these</span>
<span class="sd">        entries are masked. In the defaul infinite sites model, moments does</span>
<span class="sd">        not reliably calculate the fixed-bin entries, so you will almost always</span>
<span class="sd">        want ``mask_corners=True``. The exception is if we are simulating under</span>
<span class="sd">        the finite genome model, in which case we track the probability of</span>
<span class="sd">        a site to be fixed for either allele.</span>
<span class="sd">    :type maks_corners: bool, optional</span>
<span class="sd">    :param data_folded: If True, it is assumed that the input data is folded. An</span>
<span class="sd">        error will be raised if the input data and mask are not</span>
<span class="sd">        consistent with a folded Spectrum.</span>
<span class="sd">    :type data_folded: bool, optional</span>
<span class="sd">    :param check_folding: If True and data_folded=True, the data and mask will be</span>
<span class="sd">        checked to ensure they are consistent with a folded</span>
<span class="sd">        Spectrum. If they are not, a warning will be printed.</span>
<span class="sd">    :type check_folding: bool, optional</span>
<span class="sd">    :param pop_ids: Optional list of strings containing the population labels,</span>
<span class="sd">        with length equal to the dimension of ``data``.</span>
<span class="sd">    :type pop_ids: list of strings, optional</span>

<span class="sd">    :return: A frequency spectrum object, as a masked array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span>
        <span class="n">subtype</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">,</span>
        <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">data_folded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">check_folding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">make_mask_none</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Since a mask is given, we do not mask the corners</span>
            <span class="n">mask_corners</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">subarr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">subtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;folded&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data_folded</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">data_folded</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
                <span class="n">subarr</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">folded</span>
            <span class="k">elif</span> <span class="n">data_folded</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Data does not have same folding status as &quot;</span>
                    <span class="s2">&quot;was called for in Spectrum constructor.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">data_folded</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subarr</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="n">data_folded</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subarr</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check that if we&#39;re declaring that the input data is folded, it</span>
        <span class="c1"># actually is, and the mask reflects this.</span>
        <span class="k">if</span> <span class="n">data_folded</span><span class="p">:</span>
            <span class="n">total_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)</span>
            <span class="n">total_per_entry</span> <span class="o">=</span> <span class="n">subarr</span><span class="o">.</span><span class="n">_total_per_entry</span><span class="p">()</span>
            <span class="c1"># Which entries are nonsense in the folded fs.</span>
            <span class="n">where_folded_out</span> <span class="o">=</span> <span class="n">total_per_entry</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_folding</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">where_folded_out</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Creating Spectrum with data_folded = True, but &quot;</span>
                    <span class="s2">&quot;data has non-zero values in entries which are &quot;</span>
                    <span class="s2">&quot;nonsensical for a folded Spectrum.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">check_folding</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">where_folded_out</span><span class="p">]):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Creating Spectrum with data_folded = True, but &quot;</span>
                    <span class="s2">&quot;mask is not True for all entries which are &quot;</span>
                    <span class="s2">&quot;nonsensical for a folded Spectrum.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;pop_ids&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pop_ids</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                <span class="n">subarr</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span>
            <span class="k">elif</span> <span class="n">pop_ids</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Changing population labels in construction of new &quot;</span> <span class="s2">&quot;Spectrum.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;pop_ids must be of length equal to &quot;</span>
                        <span class="s2">&quot;dimensionality of Spectrum.&quot;</span>
                    <span class="p">)</span>
                <span class="n">subarr</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">pop_ids</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;pop_ids must be of length equal to &quot;</span> <span class="s2">&quot;dimensionality of Spectrum.&quot;</span>
                <span class="p">)</span>
            <span class="n">subarr</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">pop_ids</span>

        <span class="k">if</span> <span class="n">mask_corners</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">subarr</span><span class="o">.</span><span class="n">mask_corners</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">subarr</span>

    <span class="c1"># See http://www.scipy.org/Subclasses for information on the</span>
    <span class="c1"># __array_finalize__ and __array_wrap__ methods. I had to do some debugging</span>
    <span class="c1"># myself to discover that I also needed _update_from.</span>
    <span class="c1"># Also, see http://docs.scipy.org/doc/np/reference/arrays.classes.html</span>
    <span class="c1"># Also, see http://docs.scipy.org/doc/np/user/basics.subclassing.html</span>
    <span class="c1">#</span>
    <span class="c1"># We need these methods to ensure extra attributes get copied along when</span>
    <span class="c1"># we do arithmetic on the FS.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;folded&quot;</span><span class="p">,</span> <span class="s2">&quot;unspecified&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;pop_ids&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">return_scalar</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span>
        <span class="n">result</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;folded&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">folded</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;pop_ids&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">pop_ids</span>

    <span class="c1"># masked_array has priority 20.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Spectrum(</span><span class="si">%s</span><span class="s2">, folded=</span><span class="si">%s</span><span class="s2">, pop_ids=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">),</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1"># Functions for manipulating frequency spectra.</span>
<div class="viewcode-block" id="Spectrum.mask_corners">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.mask_corners">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mask the &#39;seen in 0 samples&#39; and &#39;seen in all samples&#39; entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Spectrum.unmask_corners">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.unmask_corners">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unmask_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmask the &#39;seen in 0 samples&#39; and &#39;seen in all samples&#39; entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Spectrum.unmask_all">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.unmask_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unmask_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmask all entires of the frequency spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_sample_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">sample_sizes</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_sample_sizes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_Npop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">Npop</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_Npop</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_ensure_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Npop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that fs has Npop dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="o">==</span> <span class="n">Npop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only compatible with </span><span class="si">%i</span><span class="s2">d spectra.&quot;</span> <span class="o">%</span> <span class="n">Npop</span><span class="p">)</span>

<div class="viewcode-block" id="Spectrum.project">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.project">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project to smaller sample size.</span>

<span class="sd">        ``project`` does *not* act in-place, so that the input frequency</span>
<span class="sd">        spectrum is not changed.</span>

<span class="sd">        :param ns: Sample sizes for new spectrum.</span>
<span class="sd">        :type ns: list of integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Requested sample sizes not of same dimension &quot;</span>
                <span class="s2">&quot;as spectrum. Perhaps you need to marginalize &quot;</span>
                <span class="s2">&quot;over some populations first?&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot project to a sample size greater than &quot;</span>
                <span class="s2">&quot;original. Original size is </span><span class="si">%s</span><span class="s2"> and requested size &quot;</span>
                <span class="s2">&quot;is </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">original_folded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span>
        <span class="c1"># If we started with an folded Spectrum, we need to unfold before</span>
        <span class="c1"># projecting.</span>
        <span class="k">if</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Iterate over each axis, applying the projection.</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">proj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">proj</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">_project_one_axis</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>

        <span class="c1"># Return folded or unfolded as original.</span>
        <span class="k">if</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_project_one_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project along a single axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This gets a little tricky with fancy indexing to make it work</span>
        <span class="c1"># for fs with arbitrary number of dimensions.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot project to a sample size greater than &quot;</span>
                <span class="s2">&quot;original. Called sizes were from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Create a new empty fs that we&#39;ll fill in below.</span>
        <span class="n">pfs</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">),</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Set up for our fancy indexes. These slices are currently like</span>
        <span class="c1"># [:,:,...]</span>
        <span class="n">from_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)]</span>
        <span class="n">to_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)]</span>
        <span class="n">proj_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">nuax</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)]</span>

        <span class="n">proj_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="c1"># For each possible number of hits.</span>
        <span class="k">for</span> <span class="n">hits</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">proj_from</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Adjust the slice in the array we&#39;re projecting from.</span>
            <span class="n">from_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">hits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># These are the least and most possible hits we could have in the</span>
            <span class="c1">#  projected fs.</span>
            <span class="n">least</span><span class="p">,</span> <span class="n">most</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">proj_from</span> <span class="o">-</span> <span class="n">hits</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">to_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">least</span><span class="p">,</span> <span class="n">most</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># The projection weights.</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">_cached_projection</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">proj_from</span><span class="p">,</span> <span class="n">hits</span><span class="p">)</span>
            <span class="n">proj_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">least</span><span class="p">,</span> <span class="n">most</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Do the multiplications</span>
            <span class="n">pfs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">to_slice</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">from_slice</span><span class="p">)]</span> <span class="o">*</span> <span class="n">proj</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">proj_slice</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">pfs</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">to_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">pfs</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">to_slice</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">from_slice</span><span class="p">)]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">pfs</span>

<div class="viewcode-block" id="Spectrum.marginalize">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.marginalize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">marginalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">over</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduced dimensionality spectrum summing over the set of populations</span>
<span class="sd">        given by ``over``.</span>

<span class="sd">        ``marginalize`` does not act in-place, so the input frequency spectrum</span>
<span class="sd">        will not be altered.</span>

<span class="sd">        :param over: List of axes to sum over. For example (0,2) will marginalize</span>
<span class="sd">            populations 0 and 2.</span>
<span class="sd">        :type over: list of integers</span>
<span class="sd">        :param mask_corners: If True, the fixed bins of the resulting spectrum will be</span>
<span class="sd">            masked. The default behavior is to mask the corners only if at least one</span>
<span class="sd">            of the corners of the input frequency spectrum is masked. If either</span>
<span class="sd">            corner is masked, the output frequency spectrum masks the fixed bins.</span>
<span class="sd">        :type mask_corners: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_plotting</span><span class="p">:</span>
            <span class="c1"># Update ModelPlot</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">ModelPlot</span><span class="o">.</span><span class="n">_get_model</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">extinction</span><span class="p">(</span><span class="n">over</span><span class="p">)</span>

        <span class="n">original_folded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span>
        <span class="c1"># If we started with an folded Spectrum, we need to unfold before</span>
        <span class="c1"># marginalizing.</span>
        <span class="k">if</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">orig_mask</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">orig_mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">orig_mask</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Marginalizing a Spectrum with internal masked values. &quot;</span>
                <span class="s2">&quot;This may not be a well-defined operation.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Do the marginalization</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">over</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">pop_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">over</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">pop_ids</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">pop_ids</span>

        <span class="k">if</span> <span class="n">mask_corners</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">mask_corners</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_corners</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">mask_corners</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">mask_corners</span><span class="p">()</span>

        <span class="c1"># Return folded or unfolded as original.</span>
        <span class="k">if</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="Spectrum.swap_axes">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.swap_axes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">swap_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses np&#39;s swapaxes function, but also swaps pop_ids as appropriate</span>
<span class="sd">        if pop_ids are given.</span>

<span class="sd">        .. note::</span>
<span class="sd">            ``fs.swapaxes(ax1, ax2)`` will still work, but if population</span>
<span class="sd">            ids are given, it won&#39;t swap the pop_ids entries as expected.</span>

<span class="sd">        :param ax1: The index of the first population to swap.</span>
<span class="sd">        :type ax1: int</span>
<span class="sd">        :param ax2: The index of the second population to swap.</span>
<span class="sd">        :type ax2: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ax1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span>
            <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ax1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop2</span><span class="p">,</span> <span class="n">pop1</span>
        <span class="k">return</span> <span class="n">output</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_counts_per_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts per population for each entry in the fs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Transpose the first access to the last, so ind[ii,jj,kk] = [ii,jj,kk]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ind</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_total_per_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total derived alleles for each entry in the fs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_counts_per_entry</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="Spectrum.log">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.log">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the natural logarithm of the entries of the frequency spectrum.</span>

<span class="sd">        Only necessary because np.ma.log now fails to propagate extra</span>
<span class="sd">        attributes after np 1.10.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">logfs</span><span class="o">.</span><span class="n">folded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span>
        <span class="n">logfs</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="k">return</span> <span class="n">logfs</span></div>


<div class="viewcode-block" id="Spectrum.fold">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.fold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a folded frequency spectrum.</span>

<span class="sd">        The folded fs assumes that information on which allele is ancestral or</span>
<span class="sd">        derived is unavailable. Thus the fs is in terms of minor allele</span>
<span class="sd">        frequency.  This makes the fs into a &quot;triangular&quot; array. If a masked cell</span>
<span class="sd">        is folded into non-masked cell, the destination cell is masked as well.</span>

<span class="sd">        Folding is not done in-place. The return value is a new Spectrum object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input Spectrum is already folded.&quot;</span><span class="p">)</span>

        <span class="c1"># How many samples total do we have? The folded fs can only contain</span>
        <span class="c1"># entries up to total_samples/2 (rounded down).</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)</span>

        <span class="n">total_per_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_per_entry</span><span class="p">()</span>

        <span class="c1"># Here&#39;s where we calculate which entries are nonsense in the folded fs.</span>
        <span class="n">where_folded_out</span> <span class="o">=</span> <span class="n">total_per_entry</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">original_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="c1"># Here we create a mask that masks any values that were masked in</span>
        <span class="c1"># the original fs (or folded onto by a masked value).</span>
        <span class="n">final_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">original_mask</span><span class="p">,</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">original_mask</span><span class="p">))</span>

        <span class="c1"># To do the actual folding, we take those entries that would be folded</span>
        <span class="c1"># out, reverse the array along all axes, and add them back to the</span>
        <span class="c1"># original fs.</span>
        <span class="nb">reversed</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">where_folded_out</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">folded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="nb">reversed</span><span class="p">)</span>
        <span class="n">folded</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">where_folded_out</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Deal with those entries where assignment of the minor allele is</span>
        <span class="c1"># ambiguous.</span>
        <span class="n">where_ambiguous</span> <span class="o">=</span> <span class="n">total_per_entry</span> <span class="o">==</span> <span class="n">total_samples</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">ambiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">where_ambiguous</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">folded</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ambiguous</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">ambiguous</span><span class="p">)</span>

        <span class="c1"># Mask out the remains of the folding operation.</span>
        <span class="n">final_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">final_mask</span><span class="p">,</span> <span class="n">where_folded_out</span><span class="p">)</span>

        <span class="n">outfs</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span>
            <span class="n">folded</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">final_mask</span><span class="p">,</span> <span class="n">data_folded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">outfs</span></div>


<div class="viewcode-block" id="Spectrum.unfold">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.unfold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an unfolded frequency spectrum.</span>

<span class="sd">        It is assumed that each state of a SNP is equally likely to be</span>
<span class="sd">        ancestral.</span>

<span class="sd">        Unfolding is not done in-place. The return value is a new Spectrum object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input Spectrum is not folded.&quot;</span><span class="p">)</span>

        <span class="c1"># Unfolding the data is easy.</span>
        <span class="n">reversed_data</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">reversed_data</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># Unfolding the mask is trickier. We want to preserve masking of entries</span>
        <span class="c1"># that were masked in the original Spectrum.</span>
        <span class="c1"># Which entries in the original Spectrum were masked solely because</span>
        <span class="c1"># they are incompatible with a folded Spectrum?</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)</span>
        <span class="n">total_per_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_per_entry</span><span class="p">()</span>
        <span class="n">where_folded_out</span> <span class="o">=</span> <span class="n">total_per_entry</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">where_folded_out</span><span class="p">)</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">newmask</span><span class="p">,</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">newmask</span><span class="p">))</span>

        <span class="n">outfs</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">newdata</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">newmask</span><span class="p">,</span> <span class="n">data_folded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outfs</span></div>


    <span class="c1"># Functions that apply demographic events, including integration.</span>
<div class="viewcode-block" id="Spectrum.split">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.split">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">new_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a population in the SFS into two populations, with the extra</span>
<span class="sd">        population placed at the end. Returns a new frequency spectrum.</span>

<span class="sd">        :param idx: The index of the population to split.</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :param n0: The sample size of the first split population.</span>
<span class="sd">        :type n0: int</span>
<span class="sd">        :param n1: The sample size of the second split population.</span>
<span class="sd">        :type n1: int</span>
<span class="sd">        :param new_ids: The population IDs of the split populations. Can only be</span>
<span class="sd">            used if pop_ids are given for the input spectrum.</span>
<span class="sd">        :type new_ids: list of strings, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot perform split on folded spectrum.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to assign ids to a SFS with no pop_ids.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_ids must be a list of two population id strings&quot;</span><span class="p">)</span>
        <span class="n">fs_split</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Manips</span><span class="o">.</span><span class="n">split_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fs_split</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
            <span class="n">fs_split</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fs_split</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fs_split</span></div>


<div class="viewcode-block" id="Spectrum.branch">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.branch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A &quot;branch&quot; event, where a population gives rise to a child population, while</span>
<span class="sd">        persisting. This is conceptually similar to the split event. The number of</span>
<span class="sd">        lineages in the new population is provided, and the number of lineages in the</span>
<span class="sd">        source/parental population is the original sample size minus the number</span>
<span class="sd">        requested for the branched population. Returns a new frequency spectrum.</span>

<span class="sd">        :param idx: The index of the population to branch.</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :param n: The sample size of the new population.</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :param new_id: The population ID of the branch populations. The parental</span>
<span class="sd">            population retains its original population ID. Can only be</span>
<span class="sd">            used if pop_ids are given for the input spectrum.</span>
<span class="sd">        :type new_ids: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot perform branch on folded spectrum.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to assign ids to a SFS with no pop_ids.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot branch population index </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> in SFS of size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">n_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">n_parent</span> <span class="o">-</span> <span class="n">n</span>
        <span class="n">fs_branch</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Manips</span><span class="o">.</span><span class="n">split_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fs_branch</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
            <span class="n">fs_branch</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fs_branch</span></div>


<div class="viewcode-block" id="Spectrum.admix">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.admix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">admix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">num_lineages</span><span class="p">,</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new frequency spectrum with an admixed population that arose through</span>
<span class="sd">        admixture from indexed populations with given number of lineages and</span>
<span class="sd">        proportions from parental populations. This serves as a wrapper for</span>
<span class="sd">        ``Manips.admix_into_new``, with the added feature of handling pop_ids.</span>

<span class="sd">        If the number of lineages that move are equal to the number</span>
<span class="sd">        of lineages previously present in a source population, that source</span>
<span class="sd">        population is marginalized.</span>

<span class="sd">        :param idx0: Index of first source population.</span>
<span class="sd">        :type idx0: int</span>
<span class="sd">        :param idx1: Index of second source population.</span>
<span class="sd">        :type idx1: int</span>
<span class="sd">        :param num_lineages: Number of lineages in the new population. Cannot be</span>
<span class="sd">            greater than the number of existing lineages in either source</span>
<span class="sd">            populations.</span>
<span class="sd">        :type num_lineages: int</span>
<span class="sd">        :param proportion: The proportion of lineages that come from the first</span>
<span class="sd">            source population (1-proportion acestry comes from the second source</span>
<span class="sd">            population). Must be a number between 0 and 1.</span>
<span class="sd">        :type proportion: float</span>
<span class="sd">        :param new_id: The ID of the new population. Can only be used if the</span>
<span class="sd">            population IDs are specified in the input SFS.</span>
<span class="sd">        :type new_id: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify new pop ids if input SFS has no pop_ids&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proportion</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">proportion</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportion must be between 0 and 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx0</span> <span class="o">==</span> <span class="n">idx1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot admix population with itself&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx0</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="ow">or</span> <span class="n">idx1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population indexes must be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fs_admix</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Manips</span><span class="o">.</span><span class="n">admix_into_new</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">num_lineages</span><span class="p">,</span> <span class="n">proportion</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">new_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_pop_ids</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span>
            <span class="c1"># remove pop ids for marginalized pops</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">num_lineages</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">new_pop_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">new_pop_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_id</span><span class="p">)</span>
            <span class="n">fs_admix</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="n">new_pop_ids</span>
        <span class="k">return</span> <span class="n">fs_admix</span></div>


<div class="viewcode-block" id="Spectrum.pulse_migrate">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.pulse_migrate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pulse_migrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_from</span><span class="p">,</span> <span class="n">idx_to</span><span class="p">,</span> <span class="n">keep_from</span><span class="p">,</span> <span class="n">proportion</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mass migration (pulse admixture) between two existing populations. The</span>
<span class="sd">        target (destination) population has the same number of lineages in the</span>
<span class="sd">        output SFS, and the source population has ``keep_from`` number of lineages</span>
<span class="sd">        after the pulse event. The proportion is the expected ancestry proportion</span>
<span class="sd">        in the target population that comes from the source population.</span>

<span class="sd">        This serves as a wrapper for ``Manips.admix_inplace``.</span>

<span class="sd">        Depending on the proportion and number of lineages, because this is an</span>
<span class="sd">        approximate operation, we often need a large number of lineages from</span>
<span class="sd">        the source population to maintain accuracy.</span>

<span class="sd">        :param idx_from: Index of source population.</span>
<span class="sd">        :type idx_from: int</span>
<span class="sd">        :param idx_to: Index of targeet population.</span>
<span class="sd">        :type idx_to: int</span>
<span class="sd">        :param keep_from: Number of lineages to keep in source population.</span>
<span class="sd">        :type keep_from: int</span>
<span class="sd">        :param proportion: Ancestry proportion of source population that migrates</span>
<span class="sd">            to target population.</span>
<span class="sd">        :type proportion: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx_from</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx_from</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="ow">or</span> <span class="n">idx_to</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx_to</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid population index for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="si">}</span><span class="s2">D SFS.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proportion</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">proportion</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportion must be between 0 and 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_from</span> <span class="o">==</span> <span class="n">idx_to</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot admix population into itself&quot;</span><span class="p">)</span>
        <span class="n">fs_pulse</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Manips</span><span class="o">.</span><span class="n">admix_inplace</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">idx_from</span><span class="p">,</span> <span class="n">idx_to</span><span class="p">,</span> <span class="n">keep_from</span><span class="p">,</span> <span class="n">proportion</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fs_pulse</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="k">return</span> <span class="n">fs_pulse</span></div>


    <span class="c1"># Integrate the SFS in-place</span>
<div class="viewcode-block" id="Spectrum.integrate">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.integrate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Npop</span><span class="p">,</span>
        <span class="n">tf</span><span class="p">,</span>
        <span class="n">dt_fac</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overdominance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">theta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">adapt_dt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">finite_genome</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">theta_fd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">theta_bd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">frozen</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to simulate the spectrum&#39;s evolution for a given set of demographic</span>
<span class="sd">        parameters. The SFS is integrated forward-in-time, and the integration</span>
<span class="sd">        occurs in-place, meaning you need only call ``fs.integrate( )``, and the</span>
<span class="sd">        ``fs`` is updated.</span>

<span class="sd">        :param Npop: List of populations&#39; relative effective sizes. Can be given</span>
<span class="sd">            as a list of positive values for constant sizes, or as a function that</span>
<span class="sd">            returns a list of sizes at a given time.</span>
<span class="sd">        :type Npop: list or function that returns a list</span>
<span class="sd">        :param tf: The total integration time in genetic units.</span>
<span class="sd">        :type tf: float</span>
<span class="sd">        :param dt_fac: The timestep factor, default is 0.02. This parameter typically</span>
<span class="sd">            does not need to be adjusted.</span>
<span class="sd">        :type dt_fac: float, optional</span>
<span class="sd">        :param gamma: Scaled selection coefficient(s), which can be either a number</span>
<span class="sd">            or a vector gamma = [gamma1,...,gammap], allowing for different selection</span>
<span class="sd">            coefficients in each population. This can also be given as function</span>
<span class="sd">            returning a number or such a vector, allowing for selection coefficients</span>
<span class="sd">            to change over time.</span>
<span class="sd">        :type gamma: float or list of floats or function that returns a float or</span>
<span class="sd">            list of floats, optional</span>
<span class="sd">        :param h: Dominance coefficient(s) (h=1/2 implies additive selection). Can be</span>
<span class="sd">            given as a number or a vector h = [h1,...,hp], or a function that returns</span>
<span class="sd">            a number or vector of coefficients, allowing for dominance coefficients</span>
<span class="sd">            to change over time.</span>
<span class="sd">        :type h: float or list of floats or function that returns a float or</span>
<span class="sd">            list of floats, optional</span>
<span class="sd">        :param overdominance: Scaled selection coefficient(s) that is applied only to</span>
<span class="sd">            heterozygotes, in a selection system with fitnesses 1:1+s:1. Underdominance</span>
<span class="sd">            can be modeled by passing a negative value. Not that this is a symmetric</span>
<span class="sd">            under/over-dominance model, in which homozygotes for either the ancestral</span>
<span class="sd">            or derived allele have equal fitness. ``gamma``, ``h``, and ``overdominance``</span>
<span class="sd">            can be combined (additively) to implement non-symmetric selection</span>
<span class="sd">            scenarios.</span>
<span class="sd">        :type overdominance: float or list of floats or function that returns a float or</span>
<span class="sd">            list of floats, optional</span>
<span class="sd">        :param m: The migration rates matrix as a 2-D array with shape nxn,</span>
<span class="sd">            where n is the number of populations. The entry of the migration</span>
<span class="sd">            matrix m[i,j] is the migration rate from pop j to pop i in genetic</span>
<span class="sd">            units, that is, normalized by :math:`2N_e`. ``m`` may be either a</span>
<span class="sd">            2-D array, or a function that returns a 2-D array (with dimensions</span>
<span class="sd">            equal to (num pops)x(num pops)).</span>
<span class="sd">        :type m: array-like, optional</span>
<span class="sd">        :param theta: The scaled mutation rate :math:`4 N_e u`, which defaults to 1.</span>
<span class="sd">            ``theta`` can be used in the reversible model in the case of symmetric</span>
<span class="sd">            mutation rates. In this case, ``theta`` must be set to &lt;&lt; 1.</span>
<span class="sd">        :type theta: float, optional</span>
<span class="sd">        :param adapt_dt: flag to allow dt correction avoiding negative entries.</span>
<span class="sd">        :type adapt_dt: bool, optional</span>
<span class="sd">        :param finite_genome: If True, simulate under the finite-genome model with</span>
<span class="sd">            reversible mutations. If using this model, we can specify the forward</span>
<span class="sd">            and backward mutation rates, which are per-base rates that are not</span>
<span class="sd">            scaled by number of mutable loci. If ``theta_fd`` and ``theta_bd``</span>
<span class="sd">            are not specified, we assume equal forward and backward mutation rates</span>
<span class="sd">            provided by ``theta``, which must be set to less that 1.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        :type finite_genome: bool, optional</span>
<span class="sd">        :param theta_fd: The forward mutation rate :math:`4 Ne u`.</span>
<span class="sd">        :type theta_fd: float, optional</span>
<span class="sd">        :param theta_bd: The backward mutation rate :math:`4 Ne v`.</span>
<span class="sd">        :type theta_bd: float, optional</span>
<span class="sd">        :param frozen: Specifies the populations that are &quot;frozen&quot;, meaning</span>
<span class="sd">            samples from that population no longer change due or contribute</span>
<span class="sd">            to migration to other populations. This feature is most often</span>
<span class="sd">            used to indicate ancient samples, for example, ancient DNA.</span>
<span class="sd">            The ``frozen`` parameter is given as a list of same length</span>
<span class="sd">            as number of pops, with ``True`` for frozen</span>
<span class="sd">            populations at the corresponding index, and ``False`` for</span>
<span class="sd">            populations that continue to evolve.</span>
<span class="sd">        :type frozen: list of bools</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tf</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Integration time cannot be negative&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">finite_genome</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="p">(</span><span class="n">theta_fd</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">theta_bd</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;In the finite genome model, theta must be much less than 1. &quot;</span>
                    <span class="s2">&quot;If symmetric mutation rates, can use theta &lt;&lt; 1. Otherwise, &quot;</span>
                    <span class="s2">&quot;theta_fd and theta_bd must be specified.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">theta_fd</span> <span class="o">=</span> <span class="n">theta_bd</span> <span class="o">=</span> <span class="n">theta</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">frozen</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">Npop</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Npop</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frozen</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">callable</span><span class="p">(</span><span class="n">Npop</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Npop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frozen</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If one or more populations are frozen, length &quot;</span>
                    <span class="s2">&quot;of frozen must match number of simulated pops.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">_plotting</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">ModelPlot</span><span class="o">.</span><span class="n">_get_model</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="n">Npop</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="n">overdominance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overdominance</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">overdominance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Integration_nomig</span><span class="o">.</span><span class="n">integrate_neutral</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">Npop</span><span class="p">,</span>
                    <span class="n">tf</span><span class="p">,</span>
                    <span class="n">dt_fac</span><span class="o">=</span><span class="n">dt_fac</span><span class="p">,</span>
                    <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                    <span class="n">finite_genome</span><span class="o">=</span><span class="n">finite_genome</span><span class="p">,</span>
                    <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                    <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                    <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Integration_nomig</span><span class="o">.</span><span class="n">integrate_nomig</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">Npop</span><span class="p">,</span>
                    <span class="n">tf</span><span class="p">,</span>
                    <span class="n">dt_fac</span><span class="o">=</span><span class="n">dt_fac</span><span class="p">,</span>
                    <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                    <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">overdominance</span><span class="o">=</span><span class="n">overdominance</span><span class="p">,</span>
                    <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                    <span class="n">finite_genome</span><span class="o">=</span><span class="n">finite_genome</span><span class="p">,</span>
                    <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                    <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                    <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="c1"># for more than 2 populations, the sparse solver</span>
                <span class="c1"># seems to be faster than the tridiag...</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">overdominance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Integration_nomig</span><span class="o">.</span><span class="n">integrate_neutral</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                        <span class="n">Npop</span><span class="p">,</span>
                        <span class="n">tf</span><span class="p">,</span>
                        <span class="n">dt_fac</span><span class="o">=</span><span class="n">dt_fac</span><span class="p">,</span>
                        <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                        <span class="n">finite_genome</span><span class="o">=</span><span class="n">finite_genome</span><span class="p">,</span>
                        <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                        <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                        <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Integration_nomig</span><span class="o">.</span><span class="n">integrate_nomig</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                        <span class="n">Npop</span><span class="p">,</span>
                        <span class="n">tf</span><span class="p">,</span>
                        <span class="n">dt_fac</span><span class="o">=</span><span class="n">dt_fac</span><span class="p">,</span>
                        <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                        <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                        <span class="n">overdominance</span><span class="o">=</span><span class="n">overdominance</span><span class="p">,</span>
                        <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                        <span class="n">finite_genome</span><span class="o">=</span><span class="n">finite_genome</span><span class="p">,</span>
                        <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                        <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                        <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Integration</span><span class="o">.</span><span class="n">integrate_nD</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">Npop</span><span class="p">,</span>
                    <span class="n">tf</span><span class="p">,</span>
                    <span class="n">dt_fac</span><span class="o">=</span><span class="n">dt_fac</span><span class="p">,</span>
                    <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                    <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">overdominance</span><span class="o">=</span><span class="n">overdominance</span><span class="p">,</span>
                    <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span>
                    <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                    <span class="n">adapt_dt</span><span class="o">=</span><span class="n">adapt_dt</span><span class="p">,</span>
                    <span class="n">finite_genome</span><span class="o">=</span><span class="n">finite_genome</span><span class="p">,</span>
                    <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                    <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                    <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                <span class="p">)</span></div>


    <span class="c1"># Functions for computing statistics from frequency spetra.</span>

<div class="viewcode-block" id="Spectrum.Fst">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.Fst">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Fst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairwise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wright&#39;s Fst between the populations represented in the fs.</span>

<span class="sd">        This estimate of Fst assumes random mating, because we don&#39;t have</span>
<span class="sd">        heterozygote frequencies in the fs.</span>

<span class="sd">        Calculation is by the method of Weir and Cockerham *Evolution* 38:1358</span>
<span class="sd">        (1984). For a single SNP, the relevant formula is at the top of page</span>
<span class="sd">        1363. To combine results between SNPs, we use the weighted average</span>
<span class="sd">        indicated by equation 10.</span>

<span class="sd">        :param pairwise: Defaults to False. If True, returns a dictionary</span>
<span class="sd">            of all pairwise Fst within the multi-dimensional spectrum.</span>
<span class="sd">        :type pairwise: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pairwise</span><span class="p">:</span>
            <span class="n">Fsts</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">to_marginalize</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
                <span class="n">to_marginalize</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">to_marginalize</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">to_marginalize</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">to_marginalize</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">fs_marg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">to_marginalize</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pair_key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pair_key</span> <span class="o">=</span> <span class="n">pair</span>
                <span class="n">Fsts</span><span class="p">[</span><span class="n">pair_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_marg</span><span class="o">.</span><span class="n">Fst</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Fsts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This gets a little obscure because we want to be able to work with</span>
            <span class="c1"># spectra of arbitrary dimension.</span>

            <span class="c1"># First quantities from page 1360</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span>
            <span class="n">nbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="n">nsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsum</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ns</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsum</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># counts_per_pop is an r+1 dimensional array, where the last axis simply</span>
            <span class="c1"># records the indices of the entry.</span>
            <span class="c1"># For example, counts_per_pop[4,19,8] = [4,19,8]</span>
            <span class="n">counts_per_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">counts_per_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="n">counts_per_pop</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># The last axis of ptwiddle is now the relative frequency of SNPs in</span>
            <span class="c1"># that bin in each of the populations.</span>
            <span class="n">ptwiddle</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">counts_per_pop</span> <span class="o">/</span> <span class="n">ns</span>

            <span class="c1"># Note that pbar is of the same shape as fs...</span>
            <span class="n">pbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ns</span> <span class="o">*</span> <span class="n">ptwiddle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsum</span>

            <span class="c1"># We need to use &#39;this_slice&#39; to get the proper aligment between</span>
            <span class="c1"># ptwiddle and pbar.</span>
            <span class="n">this_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ns</span> <span class="o">*</span> <span class="p">(</span><span class="n">ptwiddle</span> <span class="o">-</span> <span class="n">pbar</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">this_slice</span><span class="p">)])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">nbar</span>
            <span class="p">)</span>

            <span class="c1"># Note that this &#39;a&#39; differs from equation 2, because we&#39;ve used</span>
            <span class="c1"># equation 3 and b = 0 to solve for hbar.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">nbar</span>
                <span class="o">/</span> <span class="n">nc</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nbar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pbar</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pbar</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span> <span class="o">*</span> <span class="n">s2</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nbar</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nbar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pbar</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pbar</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>

            <span class="c1"># The weighted sum over loci.</span>
            <span class="n">asum</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">dsum</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">asum</span> <span class="o">/</span> <span class="p">(</span><span class="n">asum</span> <span class="o">+</span> <span class="n">dsum</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spectrum.S">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.S">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of segregating sites in the frequency spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">oldmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_corners</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">oldmask</span>
        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="Spectrum.Watterson_theta">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.Watterson_theta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Watterson_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Watterson&#39;s estimator of theta.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function is only sensible for 1-dimensional spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only defined on a one-dimensional fs.&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
        <span class="n">an</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span> <span class="o">/</span> <span class="n">an</span></div>


<div class="viewcode-block" id="Spectrum.theta_L">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.theta_L">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">theta_L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns theta_L as defined by Zeng et al. &quot;Statistical Tests for Detecting</span>
<span class="sd">        Positive Selection by Utilizing High-Frequency Variants&quot; (2006)</span>
<span class="sd">        Genetics</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function is only sensible for 1-dimensional spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only defined on a one-dimensional fs.&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spectrum.Zengs_E">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.Zengs_E">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Zengs_E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Zeng et al.&#39;s E statistic.</span>

<span class="sd">        From Zeng et al., &quot;Statistical Tests for Detecting Positive Selection by</span>
<span class="sd">        Utilizing High-Frequency Variants.&quot; *Genetics*, 2016.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_L</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Watterson_theta</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># See after Eq. 3</span>
        <span class="n">an</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># See after Eq. 9</span>
        <span class="n">bn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>

        <span class="c1"># See immediately after Eq. 12</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Watterson_theta</span><span class="p">()</span>
        <span class="n">theta_sq</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">an</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bn</span><span class="p">)</span>

        <span class="c1"># Eq. 14</span>
        <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">an</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">bn</span> <span class="o">/</span> <span class="n">an</span><span class="o">**</span><span class="mi">2</span>
            <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bn</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">bn</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">an</span><span class="p">)</span>
            <span class="o">-</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">theta_sq</span>

        <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spectrum.pi">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.pi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the estimated expected number of pairwise differences between two</span>
<span class="sd">        chromosomes in the population.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This estimate includes a factor of sample_size / (sample_size - 1)</span>
<span class="sd">            to make :math:`\\mathbb{E}[\\pi] = \\theta`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only defined for a one-dimensional SFS.&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># sample frequencies p</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="c1"># This expression derives from Gillespie&#39;s _Population_Genetics:_A</span>
        <span class="c1"># _Concise_Guide_, 2nd edition, section 2.6.</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="Spectrum.Tajima_D">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.Tajima_D">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Tajima_D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Tajima&#39;s D.</span>

<span class="sd">        Following Gillespie &quot;Population Genetics: A Concise Guide&quot; pg. 45</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only defined on a one-dimensional SFS.&quot;</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pihat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Watterson_theta</span><span class="p">()</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">a1</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">c1</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pihat</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">C</span></div>


<div class="viewcode-block" id="Spectrum.f2">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.f2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :math:`f_2(X, Y) = (pX-pY)^2`, where :math:`p` are observed</span>
<span class="sd">        allele frequencies in populations X and Y.</span>

<span class="sd">        X, and Y can be specified as population ID strings, or as indexes</span>
<span class="sd">        (but these cannot be mixed).</span>

<span class="sd">        :param X: One of the populations, as index or population ID.</span>
<span class="sd">        :param Y: The other population, as index or population ID.</span>
<span class="sd">        :return: Patterson&#39;s f2 statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">_</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Population index </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> out of bounds for SFS &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="si">}</span><span class="s2"> populations&quot;</span>
                    <span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Populations given a strings, but pop_ids is None&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> is not in pop_ids&quot;</span><span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Populations X and Y must both be population indexes or IDs&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">idx0</span> <span class="o">==</span> <span class="n">idx1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">to_marginalize</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">]]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">to_marginalize</span><span class="p">)</span>

        <span class="c1"># symmetric statistic, so idx0 vs idx1 doesn&#39;t matter</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># To account for sampling bias</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i0</span> <span class="o">*</span> <span class="p">(</span><span class="n">i0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">i1</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="n">n1</span>
            <span class="o">+</span> <span class="n">i1</span> <span class="o">*</span> <span class="p">(</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fac</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spectrum.f3">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.f3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :math:`f_3(X; Y, Z) = (X-Y)(X-Z)`. A significantly negative</span>
<span class="sd">        :math:`f_3` suggests that population X is the result of admixture</span>
<span class="sd">        between ancient populations related to Y and Z. A positive value</span>
<span class="sd">        suggests that X is an outgroup to Y and Z.</span>

<span class="sd">        X, Y, and Z can be specified as population ID strings, or as indexes</span>
<span class="sd">        (but these cannot be mixed).</span>

<span class="sd">        :param X: The &quot;test&quot; population, as index or population ID.</span>
<span class="sd">        :param Y: The first reference population, as index or population ID.</span>
<span class="sd">        :param Z: The second reference population, as index or population ID.</span>
<span class="sd">        :returns: Patterson&#39;s f3 statistic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">_</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Population index </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> out of bounds for SFS &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="si">}</span><span class="s2"> populations&quot;</span>
                    <span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">Y</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Populations given a strings, but pop_ids is None&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> is not in pop_ids&quot;</span><span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Populations X, Y and Z must each be population indexes or IDs&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">idx0</span> <span class="o">==</span> <span class="n">idx1</span> <span class="ow">or</span> <span class="n">idx0</span> <span class="o">==</span> <span class="n">idx2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">idx1</span> <span class="o">==</span> <span class="n">idx2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f2</span><span class="p">(</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">)</span>

        <span class="c1"># reorder as needed so X is first population index</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx0</span> <span class="o">&gt;</span> <span class="n">idx1</span> <span class="ow">or</span> <span class="n">idx0</span> <span class="o">&gt;</span> <span class="n">idx2</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">swap_axes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">idx0</span>
            <span class="k">if</span> <span class="n">idx2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx0</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">to_marginalize</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">to_marginalize</span><span class="p">)</span>

        <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># To account for sampling bias</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i0</span> <span class="o">*</span> <span class="p">(</span><span class="n">i0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">i1</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="n">n1</span>
            <span class="o">-</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">i2</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="n">n2</span>
            <span class="o">+</span> <span class="n">i1</span> <span class="o">*</span> <span class="n">i2</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">/</span> <span class="n">n2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fac</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spectrum.f4">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.f4">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :math:`f_4(X, Y; Z, W) = (X-Y)(Z-W)`.</span>

<span class="sd">        X, Y, Z and W can be specified as population ID strings, or as indexes</span>
<span class="sd">        (but these cannot be mixed).</span>

<span class="sd">        :param X: A population index or ID.</span>
<span class="sd">        :param Y: A population index or ID.</span>
<span class="sd">        :param Z: A population index or ID.</span>
<span class="sd">        :param W: A population index or ID.</span>
<span class="sd">        :returns: Patterson&#39;s f4 statistic (pX-pY)*(pZ-pW).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">_</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Population index </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> out of bounds for SFS &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="si">}</span><span class="s2"> populations&quot;</span>
                    <span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">Y</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="n">Z</span>
            <span class="n">idx3</span> <span class="o">=</span> <span class="n">W</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Populations given a strings, but pop_ids is None&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population </span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s2"> is not in pop_ids&quot;</span><span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">idx3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Populations X, Y and Z must each be population indexes or IDs&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">X</span> <span class="o">==</span> <span class="n">Y</span> <span class="ow">or</span> <span class="n">Z</span> <span class="o">==</span> <span class="n">W</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="o">==</span> <span class="n">Z</span> <span class="ow">and</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">W</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f2</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="o">==</span> <span class="n">W</span> <span class="ow">and</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">Z</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">f2</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="o">==</span> <span class="n">Z</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f3</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="o">==</span> <span class="n">W</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">f3</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">Z</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">f3</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">W</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f3</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">4</span>

        <span class="c1"># marginalize down to four populations</span>
        <span class="n">to_marginalize</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npop</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">to_marginalize</span><span class="p">)</span>

        <span class="c1"># reorder as needed so that X, Y, Z, W are in order</span>
        <span class="n">sort_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sort_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">sort_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span>
                <span class="n">to_swap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">sort_indexes</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">swap_axes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">to_swap</span><span class="p">)</span>
                <span class="n">sort_indexes</span><span class="p">[</span><span class="n">to_swap</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sort_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">i3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># To account for sampling bias</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i0</span> <span class="o">*</span> <span class="n">i2</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="n">n2</span>
            <span class="o">-</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">i3</span> <span class="o">/</span> <span class="n">n0</span> <span class="o">/</span> <span class="n">n3</span>
            <span class="o">-</span> <span class="n">i1</span> <span class="o">*</span> <span class="n">i2</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">/</span> <span class="n">n2</span>
            <span class="o">+</span> <span class="n">i1</span> <span class="o">*</span> <span class="n">i3</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">/</span> <span class="n">n3</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fac</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span></div>


    <span class="c1"># Functions for resampling or generating &quot;data&quot; from an SFS</span>

<div class="viewcode-block" id="Spectrum.fixed_size_sample">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.fixed_size_sample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fixed_size_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">include_masked</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a resampled SFS from the current one. Thus, the resampled SFS</span>
<span class="sd">        follows a multinomial distribution given by the proportion of sites</span>
<span class="sd">        in each bin in the original SFS.</span>

<span class="sd">        :param nsamples: Number of samples to include in the new SFS.</span>
<span class="sd">        :type nsamples: int</span>
<span class="sd">        :param include_masked: If True, use all bins from the SFS. Otherwise,</span>
<span class="sd">            use only non-masked bins. Defaults to False.</span>
<span class="sd">        :type include_masked: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pvals</span> <span class="o">=</span> <span class="n">flat</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">include_masked</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">pvals</span><span class="p">[</span><span class="n">flat</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pvals</span> <span class="o">/=</span> <span class="n">pvals</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nsamples</span><span class="p">),</span> <span class="n">pvals</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sample</span></div>


<div class="viewcode-block" id="Spectrum.sample">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.sample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a Poisson-sampled fs from the current one.</span>

<span class="sd">        Entries where the current fs is masked or 0 will be masked in the</span>
<span class="sd">        output sampled fs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These are entries where the sampling has no meaning. Either the fs is</span>
        <span class="c1"># 0 there or masked.</span>
        <span class="n">bad_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># We convert to a 1-d array for passing into the sampler</span>
        <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Filter out those bad entries.</span>
        <span class="n">means</span><span class="p">[</span><span class="n">bad_entries</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Sample</span>
        <span class="n">samp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">))</span>
        <span class="c1"># Replace bad entries...</span>
        <span class="n">samp</span><span class="p">[</span><span class="n">bad_entries</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Convert back to a properly shaped array</span>
        <span class="n">samp</span> <span class="o">=</span> <span class="n">samp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Convert to a fs and mask the bad entries</span>
        <span class="n">samp</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span>
            <span class="n">samp</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">bad_entries</span><span class="p">,</span> <span class="n">data_folded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="p">)</span>
        <span class="n">samp</span> <span class="o">=</span> <span class="n">samp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samp</span></div>


<div class="viewcode-block" id="Spectrum.genotype_matrix">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.genotype_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genotype_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diploid_genotypes</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a genotype matrix of independent loci. For multi-population spectra,</span>
<span class="sd">        the individual columns are filled in the sample order as the populations</span>
<span class="sd">        in the SFS.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Sites in the output genotype matrix are necessarily separated by</span>
<span class="sd">            infinite recombination. The SFS assumes all loci are segregating</span>
<span class="sd">            independently, so there is no linkage between them.</span>

<span class="sd">        Returns a genotype matrix of size number of sites by total sample size.</span>

<span class="sd">        :param num_sites: Defaults to None, in which case we take a poisson sample from</span>
<span class="sd">            the SFS. Otherwise, we take a fixed number of sites.</span>
<span class="sd">        :param sample_sizes: The sample size in each population, as a list with length</span>
<span class="sd">            of the number of dimension (populations) in the SFS.</span>
<span class="sd">        :diploid_genotypes: Defaults to False, in which case we return a haplotype</span>
<span class="sd">            matrix of size (num_sites x sum(sample_sizes)). If True, we return a</span>
<span class="sd">            diploid genotype matrix (filled with 0, 1, 2) of size</span>
<span class="sd">            (num_sites x sum(sample_sizes)/2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># project to sample size as needed</span>
        <span class="k">if</span> <span class="n">sample_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diploid_genotypes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">proj</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ss</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Requested diploid genotypes, but the haploid sample &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;sizes (</span><span class="si">{</span><span class="n">sample_sizes</span><span class="si">}</span><span class="s2">) are not all even.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># get sampled SFS</span>
        <span class="k">if</span> <span class="n">num_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samp</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
            <span class="n">num_sites</span> <span class="o">=</span> <span class="n">samp</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samp</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">fixed_size_sample</span><span class="p">(</span><span class="n">num_sites</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">num_sites</span> <span class="o">==</span> <span class="n">samp</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>  <span class="c1"># remove once tested</span>

        <span class="c1"># fill in genotype matrix</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_sites</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">samp</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samp</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">):</span>
                    <span class="n">g</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">)))</span>
                <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># collapse diploids if needed</span>
        <span class="n">hap_sum</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diploid_genotypes</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">hap_sum</span><span class="p">)</span>  <span class="c1"># remove once tested</span>

        <span class="c1"># shuffle genotype matrix</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>


    <span class="c1"># Functions for saving and loading frequency spectra.</span>

<div class="viewcode-block" id="Spectrum.from_file">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.from_file">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_file</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_comments</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read frequency spectrum from file.</span>

<span class="sd">        See ``to_file`` for details on the file format.</span>

<span class="sd">        :param fid: string with file name to read from or an open file object.</span>
<span class="sd">        :type fid: string</span>
<span class="sd">        :param mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in</span>
<span class="sd">            all samples&#39; entries. If False, the corners are unmasked. If unspecified</span>
<span class="sd">            (left as None), the mask is unchanged from the saved file.</span>
<span class="sd">        :type mask_corners: bool, optional</span>
<span class="sd">        :param return_comments: If true, the return value is (fs, comments), where</span>
<span class="sd">            comments is a list of strings containing the comments</span>
<span class="sd">            from the file (without #&#39;s).</span>
<span class="sd">        :type return_comments: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newfile</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Try to read from fid. If we can&#39;t, assume it&#39;s something that we can</span>
        <span class="c1"># use to open a file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
            <span class="n">newfile</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c1"># Strip out the comments</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="c1"># Read the shape of the data</span>
        <span class="n">shape_spl</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;folded&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shape_spl</span> <span class="ow">and</span> <span class="s2">&quot;unfolded&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shape_spl</span><span class="p">:</span>
            <span class="c1"># This case handles the old file format</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape_spl</span><span class="p">])</span>
            <span class="n">folded</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pop_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This case handles the new file format</span>
            <span class="n">shape</span><span class="p">,</span> <span class="n">next_ii</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">shape_spl</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">shape_spl</span><span class="p">[</span><span class="n">next_ii</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;folded&quot;</span><span class="p">,</span> <span class="s2">&quot;unfolded&quot;</span><span class="p">]:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">shape_spl</span><span class="p">[</span><span class="n">next_ii</span><span class="p">]))</span>
                <span class="n">next_ii</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">folded</span> <span class="o">=</span> <span class="n">shape_spl</span><span class="p">[</span><span class="n">next_ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;folded&quot;</span>
            <span class="c1"># Are there population labels in the file?</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">next_ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pop_ids</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pop_ids</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">fid</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">count</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="c1"># fromfile returns a 1-d array. Reshape it to the proper form.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">maskline</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maskline</span><span class="p">:</span>
            <span class="c1"># The old file format didn&#39;t have a line for the mask</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This case handles the new file format</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">maskline</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask_corners</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">mask_corners</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># If we opened a new file, clean it up.</span>
        <span class="k">if</span> <span class="n">newfile</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">data_folded</span><span class="o">=</span><span class="n">folded</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_comments</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fs</span><span class="p">,</span> <span class="n">comments</span></div>


    <span class="n">fromfile</span> <span class="o">=</span> <span class="n">from_file</span>

<div class="viewcode-block" id="Spectrum.to_file">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.to_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">comment_lines</span><span class="o">=</span><span class="p">[],</span> <span class="n">foldmaskinfo</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write frequency spectrum to file.</span>

<span class="sd">        The file format is:</span>

<span class="sd">        - Any number of comment lines beginning with a &#39;#&#39;</span>
<span class="sd">        - A single line containing N integers giving the dimensions of the fs</span>
<span class="sd">          array. So this line would be &#39;5 5 3&#39; for an SFS that was 5x5x3.</span>
<span class="sd">          (That would be 4x4x2 *samples*.)</span>
<span class="sd">        - On the *same line*, the string &#39;folded&#39; or &#39;unfolded&#39; denoting the</span>
<span class="sd">          folding status of the array</span>
<span class="sd">        - On the *same line*, optional strings each containing the population</span>
<span class="sd">          labels in quotes separated by spaces, e.g. &quot;pop 1&quot; &quot;pop 2&quot;</span>
<span class="sd">        - A single line giving the array elements. The order of elements is</span>
<span class="sd">          e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] ... fs[0,1,0] fs[0,1,1] ...</span>
<span class="sd">        - A single line giving the elements of the mask in the same order as</span>
<span class="sd">          the data line. &#39;1&#39; indicates masked, &#39;0&#39; indicates unmasked.</span>

<span class="sd">        :param fid: string with file name to write to or an open file object.</span>
<span class="sd">        :type fid: string</span>
<span class="sd">        :param precision: precision with which to write out entries of the SFS. (They</span>
<span class="sd">            are formated via %.&lt;p&gt;g, where &lt;p&gt; is the precision.) Defaults to 16.</span>
<span class="sd">        :type precision: int, optional</span>
<span class="sd">        :param comment_lines: list of strings to be used as comment lines in the header</span>
<span class="sd">            of the output file.</span>
<span class="sd">        :type comment_lines: list of strings, optional</span>
<span class="sd">        :param foldmaskinfo: If False, folding and mask and population label</span>
<span class="sd">            information will not be saved.</span>
<span class="sd">        :type foldmaskinfo: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open the file object.</span>
        <span class="n">newfile</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">):</span>
            <span class="n">newfile</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="c1"># Write comments</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">comment_lines</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# &quot;</span><span class="p">)</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># Write out the shape of the fs</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">elem</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">foldmaskinfo</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;unfolded&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;folded&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">:</span>
                    <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span>

        <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># Write the data to the file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%%</span><span class="s2">.</span><span class="si">%i</span><span class="s2">g&quot;</span> <span class="o">%</span> <span class="n">precision</span><span class="p">)</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">foldmaskinfo</span><span class="p">:</span>
            <span class="c1"># Write the mask to the file</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># Close file</span>
        <span class="k">if</span> <span class="n">newfile</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="c1">## Overide the (perhaps confusing) original np tofile method.</span>
    <span class="n">tofile</span> <span class="o">=</span> <span class="n">to_file</span>

<div class="viewcode-block" id="Spectrum.scramble_pop_ids">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.scramble_pop_ids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scramble_pop_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spectrum corresponding to scrambling individuals among populations.</span>

<span class="sd">        This is useful for assessing how diverged populations are.</span>
<span class="sd">        Essentially, it pools all the individuals represented in the fs and</span>
<span class="sd">        generates new populations of random individuals (without replacement)</span>
<span class="sd">        from that pool. If this fs is significantly different from the</span>
<span class="sd">        original, that implies population structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">original_folded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span>
        <span class="c1"># If we started with an folded Spectrum, we need to unfold before</span>
        <span class="c1"># projecting.</span>
        <span class="k">if</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>

        <span class="n">total_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">)</span>

        <span class="c1"># First generate a 1d sfs for the pooled population.</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">total_samp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># For each entry in the fs, this is the total number of derived alleles</span>
        <span class="n">total_per_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_per_entry</span><span class="p">()</span>
        <span class="c1"># Sum up to generate the equivalent 1-d spectrum.</span>
        <span class="k">for</span> <span class="n">derived</span><span class="p">,</span> <span class="n">counts</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">total_per_entry</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="n">combined</span><span class="p">[</span><span class="n">derived</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counts</span>

        <span class="c1"># Now resample back into a n-d spectrum</span>
        <span class="c1"># For each entry, this is the counts per popuation.</span>
        <span class="c1">#  e.g. counts_per_entry[3,4,5] = [3,4,5]</span>
        <span class="n">counts_per_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_per_entry</span><span class="p">()</span>
        <span class="c1"># Reshape it to be 1-d, so we can iterate over it easily.</span>
        <span class="n">counts_per_entry</span> <span class="o">=</span> <span class="n">counts_per_entry</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">resamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">counts</span><span class="p">,</span> <span class="n">derived</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">counts_per_entry</span><span class="p">,</span> <span class="n">total_per_entry</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="c1"># The probability here is</span>
            <span class="c1"># (t1 choose d1)*(t2 choose d2)/(ntot choose derived)</span>
            <span class="n">lnprob</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="n">Numerics</span><span class="o">.</span><span class="n">_lncomb</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">lnprob</span> <span class="o">-=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">_lncomb</span><span class="p">(</span><span class="n">total_samp</span><span class="p">,</span> <span class="n">derived</span><span class="p">)</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lnprob</span><span class="p">)</span>
            <span class="c1"># Assign result using the appropriate weighting</span>
            <span class="n">resamp</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">prob</span> <span class="o">*</span> <span class="n">combined</span><span class="p">[</span><span class="n">derived</span><span class="p">]</span>

        <span class="n">resamp</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">resamp</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">original_folded</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resamp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resamp</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span></div>


<div class="viewcode-block" id="Spectrum.from_data_dict">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.from_data_dict">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_data_dict</span><span class="p">(</span>
        <span class="n">data_dict</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">polarized</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spectrum from a dictionary of polymorphisms.</span>

<span class="sd">        The data dictionary should be organized as:</span>

<span class="sd">        .. code-block::</span>

<span class="sd">            {snp_id: {</span>
<span class="sd">                &#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],</span>
<span class="sd">                &#39;calls&#39;: {</span>
<span class="sd">                    &#39;YRI&#39;: (23,3),</span>
<span class="sd">                    &#39;CEU&#39;: (7,3)</span>
<span class="sd">                },</span>
<span class="sd">                &#39;outgroup_allele&#39;: &#39;T&#39;</span>
<span class="sd">            }}</span>

<span class="sd">        The &#39;calls&#39; entry gives the successful calls in each population, in the</span>
<span class="sd">        order that the alleles are specified in &#39;segregating&#39;.</span>
<span class="sd">        Non-diallelic polymorphisms are skipped.</span>

<span class="sd">        :param pop_ids: list of which populations to make fs for.</span>
<span class="sd">        :param projections: list of sample sizes to project down to for each</span>
<span class="sd">            population.</span>
<span class="sd">        :param polarized: If True, the data are assumed to be correctly polarized by</span>
<span class="sd">            &#39;outgroup_allele&#39;. SNPs in which the &#39;outgroup_allele&#39;</span>
<span class="sd">            information is missing or &#39;-&#39; or not concordant with the</span>
<span class="sd">            segregating alleles will be ignored.</span>
<span class="sd">            If False, any &#39;outgroup_allele&#39; info present is ignored,</span>
<span class="sd">            and the returned spectrum is folded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Operations using the `data_dict` are deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in version 1.5, in favor of `from_vcf` and associated functions &quot;</span>
            <span class="s2">&quot;in the `Parsing` module&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">Npops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">snp</span><span class="p">,</span> <span class="n">snp_info</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Skip SNPs that aren&#39;t biallelic.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;segregating&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">allele1</span><span class="p">,</span> <span class="n">allele2</span> <span class="o">=</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;segregating&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">polarized</span><span class="p">:</span>
                <span class="c1"># If we don&#39;t want to polarize, we can choose which allele is</span>
                <span class="c1"># derived arbitrarily since we&#39;ll fold anyways.</span>
                <span class="n">outgroup_allele</span> <span class="o">=</span> <span class="n">allele1</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="s2">&quot;outgroup_allele&quot;</span> <span class="ow">in</span> <span class="n">snp_info</span>
                <span class="ow">and</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;outgroup_allele&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span>
                <span class="ow">and</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;outgroup_allele&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;segregating&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># Otherwise we need to check that it&#39;s a useful outgroup</span>
                <span class="n">outgroup_allele</span> <span class="o">=</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;outgroup_allele&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we&#39;re polarized and we didn&#39;t have good outgroup info, skip</span>
                <span class="c1"># this SNP.</span>
                <span class="k">continue</span>

            <span class="c1"># Extract the allele calls for each population.</span>
            <span class="n">allele1_calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;calls&quot;</span><span class="p">][</span><span class="n">pop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">pop_ids</span><span class="p">]</span>
            <span class="n">allele2_calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;calls&quot;</span><span class="p">][</span><span class="n">pop</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">pop_ids</span><span class="p">]</span>
            <span class="c1"># How many chromosomes did we call successfully in each population?</span>
            <span class="n">successful_calls</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span> <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">allele1_calls</span><span class="p">,</span> <span class="n">allele2_calls</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Which allele is derived (different from outgroup)?</span>
            <span class="k">if</span> <span class="n">allele1</span> <span class="o">==</span> <span class="n">outgroup_allele</span><span class="p">:</span>
                <span class="n">derived_calls</span> <span class="o">=</span> <span class="n">allele2_calls</span>
            <span class="k">elif</span> <span class="n">allele2</span> <span class="o">==</span> <span class="n">outgroup_allele</span><span class="p">:</span>
                <span class="n">derived_calls</span> <span class="o">=</span> <span class="n">allele1_calls</span>

            <span class="c1"># To handle arbitrary numbers of populations in the fs, we need</span>
            <span class="c1"># to do some tricky slicing.</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npops</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)):</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Do the projection for this SNP.</span>
            <span class="n">pop_contribs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">successful_calls</span><span class="p">,</span> <span class="n">derived_calls</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pop_ii</span><span class="p">,</span> <span class="p">(</span><span class="n">p_to</span><span class="p">,</span> <span class="n">p_from</span><span class="p">,</span> <span class="n">hits</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">iter</span><span class="p">):</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">_cached_projection</span><span class="p">(</span><span class="n">p_to</span><span class="p">,</span> <span class="n">p_from</span><span class="p">,</span> <span class="n">hits</span><span class="p">)[</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">[</span><span class="n">pop_ii</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="n">pop_contribs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contrib</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">+=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">pop_contribs</span><span class="p">)</span>
        <span class="n">fsout</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fsout</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polarized</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fsout</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Spectrum is empty. Did you compute the outgroup alleles &quot;</span>
                    <span class="s2">&quot;at variable sites?&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fsout</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fsout</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Spectrum is empty. Check input data dictionary.&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fsout</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_count_dict</span><span class="p">(</span><span class="n">count_dict</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">polarized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Frequency spectrum from data mapping SNP configurations to counts.</span>

<span class="sd">        :param count_dict: Result of Misc.count_data_dict</span>
<span class="sd">        :param projections: List of sample sizes to project down to for each</span>
<span class="sd">            population.</span>
<span class="sd">        :param polarized: If True, only include SNPs that count_dict marks as polarized.</span>
<span class="sd">            If False, include all SNPs and fold resulting Spectrum.</span>
<span class="sd">        :param pop_ids: Optional list of strings containing the population labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Operations using the `data_dict` are deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in version 1.5, in favor of `from_vcf` and associated functions &quot;</span>
            <span class="s2">&quot;in the `Parsing` module&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># create slices for projection calculation</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">projections</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">projections</span><span class="p">)):</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">fs_total</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">called_by_pop</span><span class="p">,</span> <span class="n">derived_by_pop</span><span class="p">,</span> <span class="n">this_snp_polarized</span><span class="p">),</span>
            <span class="n">count</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">count_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">polarized</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">this_snp_polarized</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">pop_contribs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">called_by_pop</span><span class="p">,</span> <span class="n">derived_by_pop</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pop_ii</span><span class="p">,</span> <span class="p">(</span><span class="n">p_to</span><span class="p">,</span> <span class="n">p_from</span><span class="p">,</span> <span class="n">hits</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">iter</span><span class="p">):</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">_cached_projection</span><span class="p">(</span><span class="n">p_to</span><span class="p">,</span> <span class="n">p_from</span><span class="p">,</span> <span class="n">hits</span><span class="p">)[</span>
                    <span class="n">slices</span><span class="p">[</span><span class="n">pop_ii</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">pop_contribs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contrib</span><span class="p">)</span>
            <span class="n">fs_proj</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">pop_contribs</span><span class="p">)</span>

            <span class="c1"># create slices for adding projected fs to overall fs</span>
            <span class="n">fs_total</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">fs_proj</span>
        <span class="k">if</span> <span class="n">polarized</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fs_total</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fs_total</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_data_by_tri</span><span class="p">(</span><span class="n">data_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nest the data by derived context and outgroup base.</span>

<span class="sd">        The resulting dictionary contains only SNPs which are appropriate for</span>
<span class="sd">        use of Hernandez&#39;s ancestral misidentification correction. It is</span>
<span class="sd">        organized as {(derived_tri, outgroup_base): {snp_id: data,...}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Operations using the `data_dict` are deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in version 1.5, in favor of `from_vcf` and associated functions &quot;</span>
            <span class="s2">&quot;in the `Parsing` module&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">genetic_bases</span> <span class="o">=</span> <span class="s2">&quot;ACTG&quot;</span>
        <span class="k">for</span> <span class="n">snp</span><span class="p">,</span> <span class="n">snp_info</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Skip non-diallelic polymorphisms</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;segregating&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">allele1</span><span class="p">,</span> <span class="n">allele2</span> <span class="o">=</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;segregating&quot;</span><span class="p">]</span>
            <span class="c1"># Filter out SNPs where we either non-constant ingroup or outgroup</span>
            <span class="c1"># context.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ingroup_tri</span> <span class="o">=</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;context&quot;</span><span class="p">]</span>
                <span class="n">outgroup_tri</span> <span class="o">=</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;outgroup_context&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">outgroup_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">snp_info</span><span class="p">[</span><span class="s2">&quot;outgroup_allele&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Outgroup context and allele are inconsistent &quot;</span>
                    <span class="s2">&quot;for polymorphism: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">snp</span>
                <span class="p">)</span>
            <span class="n">outgroup_allele</span> <span class="o">=</span> <span class="n">outgroup_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># These are all the requirements to apply the ancestral correction.</span>
            <span class="c1"># First 2 are constant context.</span>
            <span class="c1"># Next 2 are sensible context.</span>
            <span class="c1"># Next 1 is that outgroup allele is one of the segregating.</span>
            <span class="c1"># Next 2 are that segregating alleles are sensible.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">outgroup_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">outgroup_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genetic_bases</span>
                <span class="ow">or</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genetic_bases</span>
                <span class="ow">or</span> <span class="n">outgroup_allele</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">allele1</span><span class="p">,</span> <span class="n">allele2</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">allele1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genetic_bases</span>
                <span class="ow">or</span> <span class="n">allele2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genetic_bases</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">allele1</span> <span class="o">==</span> <span class="n">outgroup_allele</span><span class="p">:</span>
                <span class="n">derived_allele</span> <span class="o">=</span> <span class="n">allele2</span>
            <span class="k">elif</span> <span class="n">allele2</span> <span class="o">==</span> <span class="n">outgroup_allele</span><span class="p">:</span>
                <span class="c1"># In this case, the second allele is non_outgroup</span>
                <span class="n">derived_allele</span> <span class="o">=</span> <span class="n">allele1</span>
            <span class="n">derived_tri</span> <span class="o">=</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">derived_allele</span> <span class="o">+</span> <span class="n">ingroup_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">setdefault</span><span class="p">((</span><span class="n">derived_tri</span><span class="p">,</span> <span class="n">outgroup_allele</span><span class="p">),</span> <span class="p">{})</span>
            <span class="n">result</span><span class="p">[</span><span class="n">derived_tri</span><span class="p">,</span> <span class="n">outgroup_allele</span><span class="p">][</span><span class="n">snp</span><span class="p">]</span> <span class="o">=</span> <span class="n">snp_info</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_data_dict_corrected</span><span class="p">(</span>
        <span class="n">data_dict</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">fux_filename</span><span class="p">,</span> <span class="n">force_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spectrum from a dictionary of polymorphisms, corrected for ancestral</span>
<span class="sd">        misidentification.</span>

<span class="sd">        The correction is based upon Hernandez, Williamson &amp; Bustamante *Mol Biol Evol*</span>
<span class="sd">        24:1792 (2007)</span>

<span class="sd">        :param force_pos: If the correction is too agressive, it may leave some small</span>
<span class="sd">            entries in the fs less than zero. If force_pos is true,</span>
<span class="sd">            these entries will be set to zero, in such a way that the</span>
<span class="sd">            total number of segregating SNPs is conserved.</span>
<span class="sd">        :param fux_filename: The name of the file containing the</span>
<span class="sd">            misidentification probabilities.</span>
<span class="sd">            The file is of the form:</span>
<span class="sd">            - # Any number of comments lines beginning with #</span>
<span class="sd">            - AAA T 0.001</span>
<span class="sd">            - AAA G 0.02</span>
<span class="sd">            - ...</span>
<span class="sd">            Where every combination of three + one bases is considered</span>
<span class="sd">            (order is not important).  The triplet is the context and</span>
<span class="sd">            putatively derived allele (x) in the reference species. The</span>
<span class="sd">            single base is the base (u) in the outgroup. The numerical</span>
<span class="sd">            value is 1-f_{ux} in the notation of the paper.</span>

<span class="sd">        The data dictionary should be organized as:</span>
<span class="sd">            {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],</span>
<span class="sd">                     &#39;calls&#39;: {&#39;YRI&#39;: (23,3),</span>
<span class="sd">                                &#39;CEU&#39;: (7,3)</span>
<span class="sd">                                },</span>
<span class="sd">                     &#39;outgroup_allele&#39;: &#39;T&#39;,</span>
<span class="sd">                     &#39;context&#39;: &#39;CAT&#39;,</span>
<span class="sd">                     &#39;outgroup_context&#39;: &#39;CAT&#39;</span>
<span class="sd">                    }</span>
<span class="sd">            }</span>
<span class="sd">        The additional entries are &#39;context&#39;, which includes the two flanking</span>
<span class="sd">        bases in the species of interest, and &#39;outgroup_context&#39;, which</span>
<span class="sd">        includes the aligned bases in the outgroup.</span>

<span class="sd">        This method skips entries for which the correction cannot be applied.</span>
<span class="sd">        Most commonly this is because of missing or non-constant context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Operations using the `data_dict` are deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in version 1.5, in favor of `from_vcf` and associated functions &quot;</span>
            <span class="s2">&quot;in the `Parsing` module&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Read the fux file into a dictionary.</span>
        <span class="n">fux_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fux_filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">fux_dict</span><span class="p">[(</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Divide the data into classes based on (&#39;context&#39;, &#39;outgroup_allele&#39;)</span>
        <span class="n">by_context</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="o">.</span><span class="n">_data_by_tri</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">by_context</span><span class="p">:</span>
            <span class="c1"># Each time through this loop, we eliminate two entries from the</span>
            <span class="c1"># data dictionary. These correspond to one class and its</span>
            <span class="c1"># corresponding misidentified class.</span>
            <span class="p">(</span><span class="n">derived_tri</span><span class="p">,</span> <span class="n">out_base</span><span class="p">),</span> <span class="n">nomis_data</span> <span class="o">=</span> <span class="n">by_context</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>

            <span class="c1"># The corresponding bases if the ancestral state had been</span>
            <span class="c1"># misidentifed.</span>
            <span class="n">mis_out_base</span> <span class="o">=</span> <span class="n">derived_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mis_derived_tri</span> <span class="o">=</span> <span class="n">derived_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">out_base</span> <span class="o">+</span> <span class="n">derived_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Get the data for that case. Note that we default to an empty</span>
            <span class="c1"># dictionary if we don&#39;t have data for that class.</span>
            <span class="n">mis_data</span> <span class="o">=</span> <span class="n">by_context</span><span class="o">.</span><span class="n">pop</span><span class="p">((</span><span class="n">mis_derived_tri</span><span class="p">,</span> <span class="n">mis_out_base</span><span class="p">),</span> <span class="p">{})</span>

            <span class="n">fux</span> <span class="o">=</span> <span class="n">fux_dict</span><span class="p">[(</span><span class="n">derived_tri</span><span class="p">,</span> <span class="n">out_base</span><span class="p">)]</span>
            <span class="n">fxu</span> <span class="o">=</span> <span class="n">fux_dict</span><span class="p">[(</span><span class="n">mis_derived_tri</span><span class="p">,</span> <span class="n">mis_out_base</span><span class="p">)]</span>

            <span class="c1"># Get the spectra for these two cases</span>
            <span class="n">Nux</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="o">.</span><span class="n">from_data_dict</span><span class="p">(</span><span class="n">nomis_data</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">,</span> <span class="n">projections</span><span class="p">)</span>
            <span class="n">Nxu</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="o">.</span><span class="n">from_data_dict</span><span class="p">(</span><span class="n">mis_data</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">,</span> <span class="n">projections</span><span class="p">)</span>

            <span class="c1"># Equations 5 &amp; 6 from the paper.</span>
            <span class="n">Nxu_rev</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">Nxu</span><span class="p">)</span>
            <span class="n">Rux</span> <span class="o">=</span> <span class="p">(</span><span class="n">fxu</span> <span class="o">*</span> <span class="n">Nux</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fxu</span><span class="p">)</span> <span class="o">*</span> <span class="n">Nxu_rev</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fux</span> <span class="o">+</span> <span class="n">fxu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Rxu</span> <span class="o">=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span>
                <span class="p">(</span><span class="n">fux</span> <span class="o">*</span> <span class="n">Nxu_rev</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fux</span><span class="p">)</span> <span class="o">*</span> <span class="n">Nux</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fux</span> <span class="o">+</span> <span class="n">fxu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">fs</span> <span class="o">+=</span> <span class="n">Rux</span> <span class="o">+</span> <span class="n">Rxu</span>

        <span class="c1"># Here we take the negative entries, and flip them back, so they end up</span>
        <span class="c1"># zero and the total number of SNPs is conserved.</span>
        <span class="k">if</span> <span class="n">force_pos</span><span class="p">:</span>
            <span class="n">negative_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">-=</span> <span class="n">negative_entries</span>
            <span class="n">fs</span> <span class="o">+=</span> <span class="n">Numerics</span><span class="o">.</span><span class="n">reverse_array</span><span class="p">(</span><span class="n">negative_entries</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">)</span>

<div class="viewcode-block" id="Spectrum.from_vcf">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.from_vcf">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_vcf</span><span class="p">(</span>
        <span class="n">vcf_file</span><span class="p">,</span>
        <span class="n">pop_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pop_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bed_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">anc_seq_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_low_confidence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_AA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_multiallelic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sample_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">folded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the SFS from genotype data stored in a VCF file. There are</span>
<span class="sd">        several optional parameters for controlling the assignment of ancestral</span>
<span class="sd">        states, filtering by quality or annotation, restricting SFS parsing to</span>
<span class="sd">        certain intervals, and adjusting the shape of the output SFS.</span>

<span class="sd">        There are several ways to specify estimated ancestral states. By</span>
<span class="sd">        default, VCF ``REF`` alleles are interpreted as ancestral alleles. In</span>
<span class="sd">        this case the output SFS should be folded, because the reference allele</span>
<span class="sd">        does not in general correspond to the ancestral allele. If ``use_AA``</span>
<span class="sd">        is True, then the ``INFO/AA`` VCF field specifies the ancestral allele.</span>
<span class="sd">        Sites where ``INFO/AA`` is absent or missing data (represented by &#39;.&#39;)</span>
<span class="sd">        are skipped, raising a warning at the first occurence.</span>

<span class="sd">        If ``anc_seq_file`` (FASTA format) is given, then ancestral alleles are</span>
<span class="sd">        read from it. Here also, sites are skipped when they lack a valid</span>
<span class="sd">        ancestral allele. This behavior is modulated by</span>
<span class="sd">        ``allow_low_confidence``: when True, sites assigned ancestral states</span>
<span class="sd">        represented in lower-case (e.g. &#39;a&#39;) are retained. This usually denotes</span>
<span class="sd">        a low-confidence assignment. Otherwise such sites are skipped. If there</span>
<span class="sd">        are sites in the VCF that fall beyond the end of the FASTA sequence</span>
<span class="sd">        which are not otherwise masked or excluded by the ``interval`` argument,</span>
<span class="sd">        an error is raised.</span>

<span class="sd">        When ``allow_multiallelic`` is False and the ancestral allele is not</span>
<span class="sd">        represented as either the reference or alternate allele at a site, that</span>
<span class="sd">        site is skipped automatically. The relationship between derived alleles</span>
<span class="sd">        at such sites is not generally clear.</span>

<span class="sd">        The parameter ``filters`` allows filtering by quality and/or annotation</span>
<span class="sd">        at the site and sample level. It should be a flat dictionary with str</span>
<span class="sd">        keys. Key-value pairs may have the following forms:</span>
<span class="sd">        </span>
<span class="sd">        - &#39;QUAL&#39; should map to a single number (float or int), imposing a minimum</span>
<span class="sd">          value for site ``QUAL`` fields.</span>
<span class="sd">        - &#39;FILTER&#39; should map to a string or a set, tuple or list of strings. For</span>
<span class="sd">          a site to pass, its ``FILTER`` field must equal either the value of</span>
<span class="sd">          &#39;FILTER&#39; (if a string) or that of one of its elements (if a set,</span>
<span class="sd">          tuple or list).</span>
<span class="sd">        - &#39;INFO/FIELD&#39; e.g. &#39;INFO/GQ&#39; may map to a number, a string, or a set,</span>
<span class="sd">          tuple or list of strings. When it maps to a number, passing sites</span>
<span class="sd">          must have ``INFO/FIELD`` greater than or equal to that number to</span>
<span class="sd">          pass. When it maps to a string, sites must have equal</span>
<span class="sd">          ``INFO/FIELD``. When it maps to a set, tuple or list of strings, the</span>
<span class="sd">          filter is said to be categorical and a site&#39;s ``INFO/FIELD`` must be</span>
<span class="sd">          a member of the set/tuple/list to pass.</span>
<span class="sd">          The types of values are not explictly checked against the proper</span>
<span class="sd">          type for their fields- e.g. if &#39;INFO/GQ&#39; maps to a string rather</span>
<span class="sd">          than a number, no explicit warning is raised, although an error will</span>
<span class="sd">          typically be thrown once parsing begins.</span>
<span class="sd">        - &#39;SAMPLE/FIELD&#39; e.g. &#39;SAMPLE/GQ&#39; imposes filters at the sample level.</span>
<span class="sd">          &#39;FORMAT/FIELD&#39; is equivalent to &#39;SAMPLE/FIELD&#39;. The &#39;FIELD&#39; should</span>
<span class="sd">          correspond to an entry in the ``FORMAT`` column of the VCF file.</span>
<span class="sd">          Typing is the same as for ``INFO/FIELD``.</span>

<span class="sd">        When fields targeted for filtering are missing (&#39;.&#39;) or absent in given</span>
<span class="sd">        lines/samples, those lines/samples are not skipped, but a one-time</span>
<span class="sd">        alert message is raised. Depending on the context, this may be a sign</span>
<span class="sd">        of misspecified filters, or it may be unproblematic. Any combination of</span>
<span class="sd">        valid filter fields is permissible.</span>

<span class="sd">        :param vcf_file: Pathname of the VCF file to parse. The file may be</span>
<span class="sd">            gzipped, bgzipped or uncompressed.</span>
<span class="sd">        :type vcf_file: str</span>
<span class="sd">        :param pop_mapping: Optional dictionary (default None) mapping</span>
<span class="sd">            population IDs to lists of VCF sample IDs. Equivalent in function</span>
<span class="sd">            to, and mutually exclusive with, ``pop_file``.</span>
<span class="sd">        :type pop_mapping: dict, optional</span>
<span class="sd">        :param pop_file: Pathname of a whitespace-separated file mapping samples</span>
<span class="sd">            to populations with the format SAMPLE POPULATION. Sample names must</span>
<span class="sd">            be unique and there should be one of them on each line (default None</span>
<span class="sd">            combines all samples into a single population &#39;ALL&#39;). Samples</span>
<span class="sd">            present in the VCF but not included here are ignored.</span>
<span class="sd">        :type pop_file: str, optional</span>
<span class="sd">        :param pops: A list of populations from ``pop_file`` to parse (default</span>
<span class="sd">            None). Only functions when ``pop_file`` is given. Populations not in</span>
<span class="sd">            ``pops`` are ignored. If None, then all populations in ``pop_file`` are</span>
<span class="sd">            included.</span>
<span class="sd">        :type pops: list of str</span>
<span class="sd">        :param bed_file: Pathname of a BED file defining the intervals within</span>
<span class="sd">            which to parse; useful for applying masks to exclude difficult-to-</span>
<span class="sd">            call or functionally constrained genomic regions (default None).</span>
<span class="sd">            BED files represent intervals as 0-indexed and half-open (the ends</span>
<span class="sd">            of intervals are noninclusive).</span>
<span class="sd">        :type bed_file: str, optional</span>
<span class="sd">        :param interval: 2-tuple or 2-list specifying a 1-indexed, half-open</span>
<span class="sd">            (upper boundary noninclusive) genomic window to parse (default</span>
<span class="sd">            None). May be used in conjuction with a BED file.</span>
<span class="sd">        :type interval: tuple or list of integers, optional</span>
<span class="sd">        :param anc_seq_file: Pathname of a FASTA file defining inferred</span>
<span class="sd">            ancestral nucleotide states (default None).</span>
<span class="sd">        :type anc_seq_file: str, optional</span>
<span class="sd">        :param allow_low_confidence: If True (default False) and ``anc_seq_file``</span>
<span class="sd">            is given, allows low-confidence ancestral state assignments-</span>
<span class="sd">            represented by lower-case nucleotide codes- to stand. If False,</span>
<span class="sd">            sites with low-confidence assignments are skipped.</span>
<span class="sd">        :type allow_low_confidence: bool, optional</span>
<span class="sd">        :param use_AA: If True, use entries in the VCF field ``INFO/AA`` to</span>
<span class="sd">            assign ancestral alleles (default False).</span>
<span class="sd">        :type use_AA: bool, optional</span>
<span class="sd">        :param filters: A dictionary mapping VCF fields to filter criteria, for</span>
<span class="sd">            imposing quantitative thresholds on measures of genotype quality and</span>
<span class="sd">            categorical requirements on annotations. Filtering is discussed</span>
<span class="sd">            above.</span>
<span class="sd">        :type filters: dict, optional</span>
<span class="sd">        :param allow_multiallelic: If True (default False), includes sites with</span>
<span class="sd">            more than one alternate allele, counting each derived allele at such</span>
<span class="sd">            sites as a separate entry in the SFS- otherwise multiallelic sites</span>
<span class="sd">            are skipped. Also allows sites where neither the reference nor any</span>
<span class="sd">            alternate allelle(s) matches the assigned ancestral state, which are</span>
<span class="sd">            skipped when False.</span>
<span class="sd">        :type allow_multiallelic: bool, optional</span>
<span class="sd">        :param sample_sizes: Dictionary mapping populations to haploid sample</span>
<span class="sd">            sizes (default None). Determines the shape of the returned SFS.</span>
<span class="sd">            Any VCF sites with sample sizes greater than ``sample_sizes`` will be</span>
<span class="sd">            projected down to match it. This may be useful when some genotype</span>
<span class="sd">            data is missing or filtered- sites with missing data are otherwise</span>
<span class="sd">            not included in the output SFS. When not given, output sample sizes</span>
<span class="sd">            default to the sample sizes implied by ``ploidy`` and the number of</span>
<span class="sd">            individuals in each population.</span>
<span class="sd">        :type sample_sizes: dict, optional</span>
<span class="sd">        :param mask_corners: If True (default), the &#39;observed in none&#39; and</span>
<span class="sd">            &#39;observed in all&#39; entries of the SFS array are masked.</span>
<span class="sd">        :type mask_corners: bool, optional</span>
<span class="sd">        :param ploidy: Optionally defines the ploidy of samples (default 2).</span>
<span class="sd">            Used to determine the haploid sample size from the number of sampled</span>
<span class="sd">            individuals when ``sample_sizes`` is not given.</span>
<span class="sd">        :type plody: int, optional</span>
<span class="sd">        :param verbose: If &gt; 0, print a progress message every ``verbose`` lines</span>
<span class="sd">            (default 0).</span>
<span class="sd">        :type verbose: int, optional</span>
<span class="sd">        :param folded: If True, return the folded SFS (default False).</span>
<span class="sd">        :type folded: bool, optional</span>
<span class="sd">        :returns: The SFS, represented as a ``moments.Spectrum`` instance.</span>
<span class="sd">        :rtype: moments.Spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">Parsing</span><span class="o">.</span><span class="n">parse_vcf</span><span class="p">(</span>
            <span class="n">vcf_file</span><span class="p">,</span>
            <span class="n">pop_mapping</span><span class="o">=</span><span class="n">pop_mapping</span><span class="p">,</span>
            <span class="n">pop_file</span><span class="o">=</span><span class="n">pop_file</span><span class="p">,</span>
            <span class="n">pops</span><span class="o">=</span><span class="n">pops</span><span class="p">,</span>
            <span class="n">bed_file</span><span class="o">=</span><span class="n">bed_file</span><span class="p">,</span>
            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
            <span class="n">anc_seq_file</span><span class="o">=</span><span class="n">anc_seq_file</span><span class="p">,</span>
            <span class="n">allow_low_confidence</span><span class="o">=</span><span class="n">allow_low_confidence</span><span class="p">,</span>
            <span class="n">use_AA</span><span class="o">=</span><span class="n">use_AA</span><span class="p">,</span>
            <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">allow_multiallelic</span><span class="o">=</span><span class="n">allow_multiallelic</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">sample_sizes</span><span class="o">=</span><span class="n">sample_sizes</span><span class="p">,</span>
            <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">,</span>
            <span class="n">folded</span><span class="o">=</span><span class="n">folded</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fs</span></div>


<div class="viewcode-block" id="Spectrum.from_demes">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.from_demes">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_demes</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span>
        <span class="n">sampled_demes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unsampled_n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a deme graph and computes the SFS. ``demes`` is a package for</span>
<span class="sd">        specifying demographic models in a user-friendly, human-readable YAML</span>
<span class="sd">        format. This function automatically parses the demographic description</span>
<span class="sd">        and returns a SFS for the specified populations and sample sizes.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If a deme sample time is requested that is earlier than the deme&#39;s</span>
<span class="sd">            end time, for example to simulate ancient samples, we must create a</span>
<span class="sd">            new population for that ancient sample. This can cause large</span>
<span class="sd">            slow-downs, as the computation cost of computing the SFS grows</span>
<span class="sd">            quickly in the number of populations.</span>

<span class="sd">        :param g: A ``demes`` DemeGraph from which to compute the SFS. The DemeGraph</span>
<span class="sd">            can either be specified as a YAML file, in which case ``g`` is a string,</span>
<span class="sd">            or as a ``DemeGraph`` object.</span>
<span class="sd">        :type g: str or :class:`demes.DemeGraph`</span>
<span class="sd">        :param sampled_demes: A list of deme IDs to take samples from. We can repeat</span>
<span class="sd">            demes, as long as the sampling of repeated deme IDs occurs at distinct</span>
<span class="sd">            times.</span>
<span class="sd">        :type sampled_demes: list of strings</span>
<span class="sd">        :param sample_sizes: A list of the same length as ``sampled_demes``,</span>
<span class="sd">            giving the sample sizes for each sampled deme.</span>
<span class="sd">        :type sample_sizes: list of ints</span>
<span class="sd">        :param sample_times: If None, assumes all sampling occurs at the end of the</span>
<span class="sd">            existence of the sampled deme. If there are</span>
<span class="sd">            ancient samples, ``sample_times`` must be a list of same length as</span>
<span class="sd">            ``sampled_demes``, giving the sampling times for each sampled</span>
<span class="sd">            deme. Sampling times are given in time units of the original deme graph,</span>
<span class="sd">            so might not necessarily be generations (e.g. if ``g.time_units`` is years)</span>
<span class="sd">        :type sample_times: list of floats, optional</span>
<span class="sd">        :param unsampled_n: The default sample size of unsampled demes, which must be</span>
<span class="sd">            greater than or equal to 4.</span>
<span class="sd">        :type unsampled_n: int, optional</span>
<span class="sd">        :param gamma: The scaled selection coefficient(s), 2*Ne*s. Defaults to None,</span>
<span class="sd">            which implies neutrality. Can be given as a scalar value, in which case</span>
<span class="sd">            all populations have the same selection coefficient. Alternatively, can</span>
<span class="sd">            be given as a dictionary, with keys given as population names in the</span>
<span class="sd">            input Demes model. Any population missing from this dictionary will be</span>
<span class="sd">            assigned a selection coefficient of zero. A non-zero default selection</span>
<span class="sd">            coefficient can be provided, using the key ``_default``. See the Demes</span>
<span class="sd">            exension documentation for more details and examples.</span>
<span class="sd">        :type gamma: float or dict</span>
<span class="sd">        :param h: The dominance coefficient(s). Defaults to additivity (or genic</span>
<span class="sd">            selection). Can be given as a scalar value, in which case all populations</span>
<span class="sd">            have the same dominance coefficient. Alternatively, can be given as a</span>
<span class="sd">            dictionary, with keys given as population names in the input Demes model.</span>
<span class="sd">            Any population missing from this dictionary will be assigned a dominance</span>
<span class="sd">            coefficient of 1/2 (additivity). A different default dominance</span>
<span class="sd">            coefficient can be provided, using the key ``_default``. See the Demes</span>
<span class="sd">            exension documentation for more details and examples.</span>
<span class="sd">        :type h: float or dict</span>
<span class="sd">        :param theta: The population-size scaled mutation rate (4*Ne*u or 4*Ne*u*L).</span>
<span class="sd">            The default value is 1. For more control of mutation rates and mutation</span>
<span class="sd">            models (including using a reversible mutation model), please use</span>
<span class="sd">            ``moments.Demes.SFS``, which has options to specify theta, the per-base</span>
<span class="sd">            mutation rate u, and/or a reversible mutation model that allows for</span>
<span class="sd">            different forward and backward mutation rates.</span>
<span class="sd">        :type theta: scalar</span>
<span class="sd">        :return: A ``moments`` site frequency spectrum, with dimension equal to the</span>
<span class="sd">            length of ``sampled_demes``, and shape equal to ``sample_sizes`` plus one</span>
<span class="sd">            in each dimension, indexing the allele frequency in each deme from 0</span>
<span class="sd">            to n[i], where i is the deme index.</span>
<span class="sd">        :rtype: :class:`moments.Spectrum`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">g</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">SFS</span><span class="p">(</span>
            <span class="n">dg</span><span class="p">,</span>
            <span class="n">sampled_demes</span><span class="p">,</span>
            <span class="n">sample_sizes</span><span class="p">,</span>
            <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">unsampled_n</span><span class="o">=</span><span class="n">unsampled_n</span><span class="p">,</span>
            <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fs</span></div>


<div class="viewcode-block" id="Spectrum.from_angsd">
<a class="viewcode-back" href="../../api/api_moments.html#moments.Spectrum.from_angsd">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_angsd</span><span class="p">(</span>
        <span class="n">sfs_file</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">folded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert ANGSD output to a moments Spectrum object. The sample sizes</span>
<span class="sd">        are given as number of haploid genome copies (twice the number of</span>
<span class="sd">        sampled diploid individuals).</span>

<span class="sd">        :param string sfs_file: The n-dimensional SFS from ANGSD. This should be a</span>
<span class="sd">            file with a single line of numbers, as entries in the SFS.</span>
<span class="sd">        :param list sample_sizes: A list of integers with length equal to the number</span>
<span class="sd">            of population, storing the haploid sample size in each population.</span>
<span class="sd">            The order must match the population order provided to ANGSD.</span>
<span class="sd">        :param list pop_ids: A list of strings equal with length equal to the number</span>
<span class="sd">            of population, specifying the population name for each.</span>
<span class="sd">        :param bool folded: If False (default), we assume ancestral states are</span>
<span class="sd">            known, returning an unfolded SFS. If True, the returned SFS is folded.</span>
<span class="sd">        :param bool mask_corners: If True (default), mask the fixed bins in the</span>
<span class="sd">            SFS. If False, the fixed bins will remain unmasked.</span>
<span class="sd">        :return: A ``moments`` site frequency spectrum.</span>
<span class="sd">        :rtype: :class:`moments.Spectrum`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pop_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;length of pop ids must equal the number of &quot;</span>
                <span class="s2">&quot;populations given by sample sizes&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Importing ANGSD-formatted data has only been tested for 2 populations&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># get the SFS data</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sfs_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_data</span><span class="p">:</span>
            <span class="n">data_line</span> <span class="o">=</span> <span class="n">f_data</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_line</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>

        <span class="c1"># check that the length of data matches the number of bins in the SFS</span>
        <span class="n">reshape_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sample_sizes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">reshape_dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size of data does not match input sample sizes&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reshape_dims</span><span class="p">)</span>

        <span class="c1"># turn into moments object</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">folded</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">fold</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fs</span></div>


    <span class="c1"># The code below ensures that when I do arithmetic with Spectrum objects,</span>
    <span class="c1"># it is not done between a folded and an unfolded array. If it is, I raise</span>
    <span class="c1"># a ValueError.</span>

    <span class="c1"># While I&#39;m at it, I&#39;m also fixing the annoying behavior that if a1 and a2</span>
    <span class="c1"># are masked arrays, and a3 = a1 + a2. Then wherever a1 or a2 was masked,</span>
    <span class="c1"># a3.data ends up with the a1.data values, rather than a1.data + a2.data.</span>
    <span class="c1"># Note that this fix doesn&#39;t work for operation by np.ma.exp and</span>
    <span class="c1"># np.ma.log. Guess I can&#39;t have everything.</span>

    <span class="c1"># I&#39;m using exec here to avoid copy-pasting a dozen boiler-plate functions.</span>
    <span class="c1"># The calls to check_folding_equal ensure that we don&#39;t try to combine</span>
    <span class="c1"># folded and unfolded Spectrum objects.</span>

    <span class="c1"># I set check_folding = False in the constructor because it raises useless</span>
    <span class="c1"># warnings when, for example, I do (model + 1).</span>

    <span class="c1"># These functions also ensure that the pop_ids</span>
    <span class="c1"># get properly copied over.</span>

    <span class="c1"># This is pretty advanced Python voodoo, so don&#39;t fret if you don&#39;t</span>
    <span class="c1"># understand it at first glance. :-)</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;__add__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__radd__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__sub__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rsub__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__mul__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rmul__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__div__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rdiv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__truediv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rtruediv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__floordiv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rfloordiv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rpow__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pow__&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="n">exec</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def %(method)s(self, other):</span>
<span class="sd">    self._check_other_folding(other)</span>
<span class="sd">    if isinstance(other, np.ma.masked_array):</span>
<span class="sd">        newdata = self.data.%(method)s (other.data)</span>
<span class="sd">        newmask = np.ma.mask_or(self.mask, other.mask)</span>
<span class="sd">    else:</span>
<span class="sd">        newdata = self.data.%(method)s (other)</span>
<span class="sd">        newmask = self.mask</span>
<span class="sd">    newpop_ids = self.pop_ids</span>
<span class="sd">    if hasattr(other, &#39;pop_ids&#39;):</span>
<span class="sd">        if other.pop_ids is None:</span>
<span class="sd">            newpop_ids = self.pop_ids</span>
<span class="sd">        elif self.pop_ids is None:</span>
<span class="sd">            newpop_ids = other.pop_ids</span>
<span class="sd">        elif other.pop_ids != self.pop_ids:</span>
<span class="sd">            logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;</span>
<span class="sd">                        &#39;Resulting pop_id may not be correct.&#39;)</span>
<span class="sd">    outfs = self.__class__.__new__(self.__class__, newdata, newmask, </span>
<span class="sd">                                   mask_corners=False, data_folded=self.folded,</span>
<span class="sd">                                   check_folding=False, pop_ids=newpop_ids)</span>
<span class="sd">    return outfs</span>
<span class="sd">&quot;&quot;&quot;</span>
            <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="c1"># Methods that modify the Spectrum in-place.</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;__iadd__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__isub__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__imul__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__idiv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__itruediv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ifloordiv__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ipow__&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="n">exec</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def %(method)s(self, other):</span>
<span class="sd">    self._check_other_folding(other)</span>
<span class="sd">    if isinstance(other, np.ma.masked_array):</span>
<span class="sd">        self.data.%(method)s (other.data)</span>
<span class="sd">        self.mask = np.ma.mask_or(self.mask, other.mask)</span>
<span class="sd">    else:</span>
<span class="sd">        self.data.%(method)s (other)</span>
<span class="sd">    if hasattr(other, &#39;pop_ids&#39;) and other.pop_ids is not None\</span>
<span class="sd">             and other.pop_ids != self.pop_ids:</span>
<span class="sd">        logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;</span>
<span class="sd">                    &#39;Resulting pop_id may not be correct.&#39;)</span>
<span class="sd">    return self</span>
<span class="sd">&quot;&quot;&quot;</span>
            <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_other_folding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure other Spectrum has same .folded status</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">folded</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot operate with a folded Spectrum and an &quot;</span> <span class="s2">&quot;unfolded one.&quot;</span>
            <span class="p">)</span></div>



<span class="c1"># Allow spectrum objects to be pickled.</span>
<span class="c1"># See http://effbot.org/librarybook/copy-reg.htm</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">copy_reg</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">Spectrum_unpickler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data_folded</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">mask_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">data_folded</span><span class="o">=</span><span class="n">data_folded</span><span class="p">,</span>
            <span class="n">check_folding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">Spectrum_pickler</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">Spectrum_unpickler</span><span class="p">,</span>
            <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">folded</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">copy_reg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">,</span> <span class="n">Spectrum_pickler</span><span class="p">,</span> <span class="n">Spectrum_unpickler</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">copyreg</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">Spectrum_unpickler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data_folded</span><span class="p">,</span> <span class="n">pop_ids</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">mask_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">data_folded</span><span class="o">=</span><span class="n">data_folded</span><span class="p">,</span>
            <span class="n">check_folding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">pop_ids</span><span class="o">=</span><span class="n">pop_ids</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">Spectrum_pickler</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">Spectrum_unpickler</span><span class="p">,</span>
            <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">folded</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">,</span> <span class="n">Spectrum_pickler</span><span class="p">,</span> <span class="n">Spectrum_unpickler</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Aaron Ragsdale.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>