

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>moments.Demes.Inference &mdash; moments 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            moments
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SFS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/sfs.html">The Site Frequency Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/parsing.html">Parsing the SFS from a VCF file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/inference.html">SFS Inference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Linkage disequilibrium</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/ld.html">Multi-population LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/parsing.html">Parsing LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/inference.html">Inferring demography with LD</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/demes.html">Specifying models with <code class="docutils literal notranslate"><span class="pre">demes</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/two_locus.html">Two-locus frequency spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/triallele.html">Triallele frequency spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/diversity.html">Demography and genetic diversity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/dfe.html">DFE inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/recombination.html">Linkage disequilibrium and recombination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/two_locus_selection.html">Selection at two loci</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data types and functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_moments.html">API for site frequency spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_ld.html">API for linkage disequilibrium</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_demes.html">API for <code class="docutils literal notranslate"><span class="pre">demes</span></code> functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">moments</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">moments.Demes.Inference</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for moments.Demes.Inference</h1><div class="highlight"><pre>
<span></span><span class="c1"># Infer a demographic history using a demes graph as input.  The input demes</span>
<span class="c1"># YAML stores in initial parameter guesses and fixed parameters.  A second YAML</span>
<span class="c1"># specifies parameters to be fit that align with the input YAML demography.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">demes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ruamel.yaml</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">moments</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.optimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="o">,</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>


<span class="c1">################################################</span>
<span class="c1"># Functions shared for SFS and LD optimization #</span>
<span class="c1">################################################</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_demes_dict</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The loaded builder has demes, migrations, and pulses, each as a list of items.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">load_asdict</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">builder</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_params_dict</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Options:</span>
<span class="sd">    - parameters (what to fit)</span>
<span class="sd">    - constraints</span>
<span class="sd">    Below note is from the demes load_dump.py file, re: YAML support in python.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: The state of Python YAML libraries in 2020 leaves much to be desired.</span>
    <span class="c1"># The pyyaml library supports only YAML v1.1, which has some awkward corner</span>
    <span class="c1"># cases that have been fixed in YAML v1.2. A fork of pyaml, ruamel.yaml,</span>
    <span class="c1"># does support YAML v1.2, and introduces a new API for parsing/emitting</span>
    <span class="c1"># with additional features and desirable behaviour.</span>
    <span class="c1"># However, neither pyyaml nor ruamel guarantee API stability, and neither</span>
    <span class="c1"># provide complete reference documentation for their APIs.</span>
    <span class="c1"># The YAML code in demes is limited to the following two functions,</span>
    <span class="c1"># which are hopefully simple enough to not suffer from API instability.</span>

    <span class="c1"># with open(fname, &quot;r&quot;) as fin:</span>
    <span class="c1">#    options = ruamel.yaml.load(fin, Loader=ruamel.yaml.Loader)</span>
    <span class="k">with</span> <span class="n">ruamel</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">YAML</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">yaml</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fin</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;parameters&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameters to fit must be specified&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">options</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_deme_map</span><span class="p">(</span><span class="n">builder</span><span class="p">):</span>
    <span class="n">deme_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">deme</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">deme</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">])}</span>
    <span class="k">return</span> <span class="n">deme_map</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_value</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If there are more than one, check that they are equal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">deme_map</span> <span class="o">=</span> <span class="n">_get_deme_map</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;demes&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">deme</span><span class="p">,</span> <span class="n">k0</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">deme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deme_map</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2"> not in deme graph, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;which has </span><span class="si">{</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">builder</span><span class="p">[</span><span class="s1">&#39;demes&#39;</span><span class="p">]]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span> <span class="s2">&quot;epochs&quot;</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k2</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">][</span><span class="n">k1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][</span><span class="n">k2</span><span class="p">][</span>
                                            <span class="n">attribute</span>
                                        <span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                        <span class="sa">f</span><span class="s2">&quot;can&#39;t get </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> from epoch </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2"> &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;from deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="p">)</span>
                        <span class="k">elif</span> <span class="n">k1</span> <span class="o">==</span> <span class="s2">&quot;proportions&quot;</span><span class="p">:</span>
                            <span class="n">prop_idx</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">][</span><span class="n">k1</span><span class="p">]</span>
                            <span class="n">prop_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">prop_idx</span> <span class="o">&gt;=</span> <span class="n">prop_len</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;can&#39;t get proportion index </span><span class="si">{</span><span class="n">prop_idx</span><span class="si">}</span><span class="s2"> from deme &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">, which has length </span><span class="si">{</span><span class="n">prop_len</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][</span><span class="n">prop_idx</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;can&#39;t get value from </span><span class="si">{</span><span class="n">k1</span><span class="si">}</span><span class="s2"> in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k0</span> <span class="o">==</span> <span class="s2">&quot;start_time&quot;</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k0</span><span class="p">])</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t get </span><span class="si">{</span><span class="n">k0</span><span class="si">}</span><span class="s2"> from deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot optimize </span><span class="si">{</span><span class="n">k0</span><span class="si">}</span><span class="s2"> in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;migrations&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mig_idx</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">][</span><span class="n">mig_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;pulses&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pulse_idx</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
                    <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">][</span><span class="n">pulse_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attribute</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">][</span><span class="n">pulse_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot optimize </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> from a pulse event&quot;</span><span class="p">)</span>
    <span class="n">unique_inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t find inputs&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_inputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found multiple input values for </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_value</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">new_val</span><span class="p">):</span>
    <span class="n">deme_map</span> <span class="o">=</span> <span class="n">_get_deme_map</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;demes&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">deme</span><span class="p">,</span> <span class="n">k0</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">deme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deme_map</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2"> not in deme graph, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;which has </span><span class="si">{</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">builder</span><span class="p">[</span><span class="s1">&#39;demes&#39;</span><span class="p">]]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span> <span class="s2">&quot;epochs&quot;</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k2</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">][</span><span class="n">k1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][</span><span class="n">k2</span><span class="p">][</span>
                                        <span class="n">attribute</span>
                                    <span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                        <span class="sa">f</span><span class="s2">&quot;can&#39;t set </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> for epoch </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2"> &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="p">)</span>
                        <span class="k">elif</span> <span class="n">k1</span> <span class="o">==</span> <span class="s2">&quot;proportions&quot;</span><span class="p">:</span>
                            <span class="n">prop_idx</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="p">][</span><span class="n">k1</span><span class="p">]</span>
                            <span class="n">prop_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">prop_idx</span> <span class="o">&gt;=</span> <span class="n">prop_len</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;can&#39;t get proportion index </span><span class="si">{</span><span class="n">prop_idx</span><span class="si">}</span><span class="s2"> from deme &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">, which has length </span><span class="si">{</span><span class="n">prop_len</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">prop_idx</span> <span class="o">==</span> <span class="n">prop_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;can&#39;t set last proportion index in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                            <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][</span><span class="n">prop_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
                            <span class="c1"># last entry in proportions must be one minus the sum</span>
                            <span class="c1"># of all other entries</span>
                            <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span>
                                <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span>
                            <span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative proportion in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span>
                            <span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;proportion larger than 1 in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;can&#39;t set value from </span><span class="si">{</span><span class="n">k1</span><span class="si">}</span><span class="s2"> in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k0</span> <span class="o">==</span> <span class="s2">&quot;start_time&quot;</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme_map</span><span class="p">[</span><span class="n">deme</span><span class="p">]][</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t set </span><span class="si">{</span><span class="n">k0</span><span class="si">}</span><span class="s2"> for deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t set </span><span class="si">{</span><span class="n">k0</span><span class="si">}</span><span class="s2"> in deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;migrations&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mig_idx</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">][</span><span class="n">mig_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
        <span class="k">if</span> <span class="s2">&quot;pulses&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pulse_idx</span><span class="p">,</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
                    <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">][</span><span class="n">pulse_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attribute</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">builder</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">][</span><span class="n">pulse_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set new </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> in a pulse event&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">builder</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">new_val</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]):</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">_set_value</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">],</span> <span class="n">new_val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">builder</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_up_params_and_bounds</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">builder</span><span class="p">):</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">deme_map</span> <span class="o">=</span> <span class="n">_get_deme_map</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]:</span>
        <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="s2">&quot;lower_bound&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
            <span class="n">lower_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;lower_bound&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;upper_bound&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
            <span class="n">upper_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;upper_bound&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upper_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lower_bound</span> <span class="o">&gt;=</span> <span class="n">upper_bound</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All lower bounds must be less than upper bounds&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p0</span> <span class="o">&lt;=</span> <span class="n">lower_bound</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All initial parameters must be greater than lower bound&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p0</span> <span class="o">&gt;=</span> <span class="n">upper_bound</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All initial parameters must be less than upper bound&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_up_constraints</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;constraints&quot;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="c1"># check that constraints are valid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">v</span><span class="p">[</span><span class="s2">&quot;constraint&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;less_than&quot;</span><span class="p">,</span> <span class="s2">&quot;greater_than&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;constraints&quot;</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constraints must be &#39;greater_than&#39; or &#39;less_than&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;constraints&quot;</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constraints must be between two parameters&quot;</span><span class="p">)</span>
        <span class="n">params_to_fit</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;constraints&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_to_fit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parameter </span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> not in parameters to fit&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_to_fit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parameter </span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> not in parameters to fit&quot;</span><span class="p">)</span>
        <span class="c1"># set up constraints function</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">x</span><span class="p">[</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cons</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
                <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cons</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">if</span> <span class="n">cons</span><span class="p">[</span><span class="s2">&quot;constraint&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;greater_than&quot;</span>
                <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cons</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
                <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cons</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
                <span class="k">for</span> <span class="n">cons</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;constraints&quot;</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">constraints</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_perturb_params_constrained</span><span class="p">(</span>
    <span class="n">p0</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">100</span>
<span class="p">):</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">conditions_satisfied</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">conditions_satisfied</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tries</span> <span class="o">==</span> <span class="n">reps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to set up initial parameters with constraints&quot;</span><span class="p">)</span>
        <span class="c1"># perturb initial parameters and make sure they are within our bounds</span>
        <span class="n">p_guess</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">fold</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_guess</span> <span class="o">&lt;=</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_guess</span> <span class="o">&gt;=</span> <span class="n">upper_bound</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_guess</span><span class="p">)):</span>
                <span class="n">tries_bounds</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">p_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lower_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">p_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">upper_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">tries_bounds</span> <span class="o">==</span> <span class="n">reps</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Failed to set up initial parameters within bounds&quot;</span>
                        <span class="p">)</span>
                    <span class="n">p_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">fold</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">tries_bounds</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># check that our constraints are satisfied</span>
        <span class="n">conditions_satisfied</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cons</span><span class="p">(</span><span class="n">p_guess</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">conditions_satisfied</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tries</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">p_guess</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_root</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">predecessors</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deme_id</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_write_uncerts_output</span><span class="p">(</span>
    <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">uncerts_out</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">output_stream</span>
<span class="p">):</span>
    <span class="n">output_string</span> <span class="o">=</span> <span class="s2">&quot;#param</span><span class="se">\t</span><span class="s2">opt_value</span><span class="se">\t</span><span class="s2">std_err</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">stderr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">uncerts_out</span><span class="p">):</span>
        <span class="n">output_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">opt</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">stderr</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Did not write output - </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2"> already exists. The uncertainties &quot;</span>
            <span class="s2">&quot;are printed below. To overwrite in future, set overwrite=True.&quot;</span>
            <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
        <span class="p">)</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_string</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_string</span><span class="p">)</span>


<span class="n">_out_of_bounds_val</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e12</span>
<span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>


<span class="c1">################################################################</span>
<span class="c1"># Objective function and inference method for SFS optimization #</span>
<span class="c1">################################################################</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_object_func</span><span class="p">(</span>
    <span class="n">params</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">builder</span><span class="p">,</span>
    <span class="n">options</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_ancestral_misid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># check bounds</span>
    <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">params</span> <span class="o">&lt;</span> <span class="n">lower_bound</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>
    <span class="k">if</span> <span class="n">upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">params</span> <span class="o">&gt;</span> <span class="n">upper_bound</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>
    <span class="c1"># check constraints</span>
    <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cons</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>

    <span class="k">global</span> <span class="n">_counter</span>
    <span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># update builder</span>
    <span class="n">demo_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="n">fit_ancestral_misid</span><span class="p">]</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">demo_params</span><span class="p">)</span>

    <span class="c1"># build graph and compute SFS</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
    <span class="n">sampled_demes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span>
    <span class="n">sample_sizes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span>

    <span class="n">end_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">}</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># check for any ancient samples, which have pop id</span>
    <span class="c1"># &quot;{deme.name}_sampled_{gen}_{frac_gen}&quot;</span>
    <span class="n">input_sampled_demes</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">deme</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">deme</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
            <span class="n">input_sampled_demes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_times</span><span class="p">[</span><span class="n">deme</span><span class="p">])</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">SFS</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">input_sampled_demes</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">uL</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">fit_ancestral_misid</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">flip_ancestral_misid</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># get log-likelihood</span>
    <span class="k">if</span> <span class="n">uL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">LL</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">ll</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LL</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">ll_multinom</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># print outputs if verbose &gt; 0</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_counter</span> <span class="o">%</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">param_str</span> <span class="o">=</span> <span class="s2">&quot;array([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%- 12g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]))</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-8i</span><span class="s2">, </span><span class="si">%-12g</span><span class="s2">, </span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_counter</span><span class="p">,</span> <span class="n">LL</span><span class="p">,</span> <span class="n">param_str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">))</span>
        <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">LL</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_object_func_log</span><span class="p">(</span><span class="n">log_params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objective function for optimization in log(params).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_object_func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_params</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="optimize">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.Inference.optimize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span>
    <span class="n">deme_graph</span><span class="p">,</span>
    <span class="n">inference_options</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">perturb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fmin&quot;</span><span class="p">,</span>
    <span class="n">fit_ancestral_misid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">misid_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
    <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize demography given a deme graph of initial and fixed parameters and</span>
<span class="sd">    inference options that specify which parameters to fit, and bounds or constraints</span>
<span class="sd">    on those parameters.</span>

<span class="sd">    :param deme_graph: A demographic model as a YAML file in ``demes`` format. This</span>
<span class="sd">        should be given as a string specifying the path and file name of the model.</span>
<span class="sd">    :param inference_options: A second YAML file, specifying the parameters to be</span>
<span class="sd">        optimized, parameter bounds, and constraints between parameters. Please see</span>
<span class="sd">        the documentation at</span>
<span class="sd">        https://momentsld.github.io/moments/extensions/demes.html#the-options-file</span>
<span class="sd">    :param data: The SFS to fit, which must have pop_ids specified. Can either be a</span>
<span class="sd">        Spectrum object or the file path to the stored frequency spectrum. The</span>
<span class="sd">        populations in the SFS (as given by ``sfs.pop_ids``) need to be present in</span>
<span class="sd">        the demographic model and have matching IDs.</span>
<span class="sd">    :param maxiter: The maximum number of iterations to run optimization. Defaults</span>
<span class="sd">        to 1000. Note: maxiter does not seem to work with the Powell method! This</span>
<span class="sd">        appears to be a bug within scipy.optimize.</span>
<span class="sd">    :param perturb: The perturbation amount of the initial parameters. Defaults to</span>
<span class="sd">        zero, in which case we do not perturb the initial parameters in the input</span>
<span class="sd">        demes YAML. If perturb is greater than zero, the initial parameters in the input</span>
<span class="sd">        YAML are randomly perturbed by up to `perturb`-fold.</span>
<span class="sd">    :param verbose: The frequency to print updates to `output_stream` if greater than 1.</span>
<span class="sd">    :param uL: The mutuation rate scaled by number of callable sites, so that theta</span>
<span class="sd">        is the compound parameter 4*Ne*uL. If given, we optimize with `multinom=False`,</span>
<span class="sd">        and theta is determined by taking Ne as the ancestral or root population size,</span>
<span class="sd">        which can be fit. Defaults to None. If uL is not given, we use `multinom=True`</span>
<span class="sd">        and we likely do not want to fit the ancestral population size.</span>
<span class="sd">    :param log: If True, optimize over log of the parameters.</span>
<span class="sd">    :param method: The optimization method. Available methods are &quot;fmin&quot;, &quot;powell&quot;,</span>
<span class="sd">        and &quot;lbfgsb&quot;.</span>
<span class="sd">    :param fit_ancestral_misid: If True, we fit the probability that the ancestral</span>
<span class="sd">        state of a given SNP is misidenitified, resulting in ancestral/derived</span>
<span class="sd">        labels being flipped. Note: this is only allowed with *unfolded* spectra.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :param misid_guess: Defaults to 0.01.</span>
<span class="sd">    :output_stream: Defaults to standard output. Can be given an open file stream</span>
<span class="sd">        instead or other output stream.</span>
<span class="sd">    :param output: If given, the filename for the output best-fit model YAML.</span>
<span class="sd">    :param overwrite: If True, overwrites any existing file with the same output</span>
<span class="sd">        name.</span>
<span class="sd">    :return: List of parameter names, optimal parameters, and LL</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># constraints. Other arguments should be kw args in the function.</span>

    <span class="c1"># load file, data,</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_get_demes_dict</span><span class="p">(</span><span class="n">deme_graph</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">_get_params_dict</span><span class="p">(</span><span class="n">inference_options</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data SFS must specify population IDs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pop_ids and sample_sizes have different lengths&quot;</span><span class="p">)</span>

    <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_set_up_params_and_bounds</span><span class="p">(</span>
        <span class="n">options</span><span class="p">,</span> <span class="n">builder</span>
    <span class="p">)</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="n">_set_up_constraints</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_ancestral_misid</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">folded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data is folded - can only fit ancestral misid using unfolded data&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">misid_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">misid_guess</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;p_misid&quot;</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="p">[</span><span class="n">misid_guess</span><span class="p">]))</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lower_bound</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper_bound</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">perturb</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">perturb</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;perturb must be a non-negative number&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perturb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;perturb must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">perturb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">_perturb_params_constrained</span><span class="p">(</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">perturb</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">constraints</span>
        <span class="p">)</span>

    <span class="n">available_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fmin&quot;</span><span class="p">,</span> <span class="s2">&quot;powell&quot;</span><span class="p">,</span> <span class="s2">&quot;lbfgsb&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> not available,  must be one of </span><span class="si">{</span><span class="n">available_methods</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># rescale if log</span>
    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">obj_fun</span> <span class="o">=</span> <span class="n">_object_func_log</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_fun</span> <span class="o">=</span> <span class="n">_object_func</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">builder</span><span class="p">,</span>
        <span class="n">options</span><span class="p">,</span>
        <span class="n">lower_bound</span><span class="p">,</span>
        <span class="n">upper_bound</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
        <span class="n">uL</span><span class="p">,</span>
        <span class="n">fit_ancestral_misid</span><span class="p">,</span>
        <span class="n">output_stream</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># run optimization</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fmin&quot;</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span> <span class="o">=</span> <span class="n">outputs</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;powell&quot;</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin_powell</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="n">direc</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span> <span class="o">=</span> <span class="n">outputs</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lbfgsb&quot;</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin_l_bfgs_b</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">iprint</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">pgtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">approx_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="n">info_dict</span> <span class="o">=</span> <span class="n">outputs</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">xopt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xopt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">xopt</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Did not write output YAML - </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2"> already exists. The model is &quot;</span>
                <span class="s2">&quot;printed below. To overwrite, set overwrite=True.&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
            <span class="p">)</span>
            <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
            <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">demes</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span></div>



<span class="c1">#################################################################</span>
<span class="c1"># Methods for computing confidence intervals from SFS inference #</span>
<span class="c1">#################################################################</span>

<span class="c1"># Cache evaluations of the frequency spectrum inside our hessian/J</span>
<span class="c1"># evaluation function</span>

<span class="n">_sfs_cache</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_godambe</span><span class="p">(</span>
    <span class="n">func_ex</span><span class="p">,</span>
    <span class="n">all_boot</span><span class="p">,</span>
    <span class="n">p0</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">,</span>
    <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">all_boot_uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">just_hess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># taken and adapted from moments.Godambe, to include bootstraps over uL</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">uL</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_sfs_cache</span><span class="p">:</span>
            <span class="n">_sfs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_ex</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="n">uL</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">_sfs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">moments</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">ll</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log_func</span><span class="p">(</span><span class="n">logparams</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logparams</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="n">uL</span><span class="p">)</span>

    <span class="c1"># First calculate the observed hessian</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="o">-</span><span class="n">moments</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">get_hess</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">uL</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="o">-</span><span class="n">moments</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">get_hess</span><span class="p">(</span><span class="n">log_func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">uL</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">just_hess</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hess</span>

    <span class="c1"># Now the expectation of J over the bootstrap data</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)))</span>
    <span class="c1"># cU is a column vector</span>
    <span class="n">cU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">all_boot_uL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_boot_uL</span> <span class="o">=</span> <span class="p">[</span><span class="n">uL</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">all_boot</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">boot</span><span class="p">,</span> <span class="n">uL</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_boot</span><span class="p">,</span> <span class="n">all_boot_uL</span><span class="p">)):</span>
        <span class="n">boot</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span><span class="n">boot</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">grad_temp</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_grad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">boot</span><span class="p">,</span> <span class="n">uL</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_temp</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_grad</span><span class="p">(</span>
                <span class="n">log_func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">boot</span><span class="p">,</span> <span class="n">uL</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">J_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">grad_temp</span><span class="p">,</span> <span class="n">grad_temp</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span> <span class="o">+</span> <span class="n">J_temp</span>
        <span class="n">cU</span> <span class="o">=</span> <span class="n">cU</span> <span class="o">+</span> <span class="n">grad_temp</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">J</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boot</span><span class="p">)</span>
    <span class="n">cU</span> <span class="o">=</span> <span class="n">cU</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boot</span><span class="p">)</span>

    <span class="c1"># G = H*J^-1*H</span>
    <span class="n">J_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">godambe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span> <span class="n">J_inv</span><span class="p">),</span> <span class="n">hess</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">godambe</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">cU</span>


<div class="viewcode-block" id="uncerts">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.Inference.uncerts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">uncerts</span><span class="p">(</span>
    <span class="n">deme_graph</span><span class="p">,</span>
    <span class="n">inference_options</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">bootstraps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bootstraps_uL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;FIM&quot;</span><span class="p">,</span>
    <span class="n">fit_ancestral_misid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">misid_fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
    <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute uncertainties for fitted parameters, using the output YAML from</span>
<span class="sd">    ``moments.Demes.Inference.optimize()``.</span>

<span class="sd">    :param deme_graph: The file path to the output demes graph from `optimize()`.</span>
<span class="sd">    :type deme_graph: str</span>
<span class="sd">    :param inference_options: The same options file used in the original optimization.</span>
<span class="sd">    :type inference_options: str</span>
<span class="sd">    :param data: The same data SFS used in the origional optimization.</span>
<span class="sd">    :type data: moments.Spectrum</span>
<span class="sd">    :param bootstraps: A list of bootstrap replicates of the SFS. See documentation</span>
<span class="sd">        for examples of computing block-bootstrap replicate data.</span>
<span class="sd">    :type bootstraps: list</span>
<span class="sd">    :param uL: The sequence length-scaled mutation rate. This must be provided if</span>
<span class="sd">        it was used in the original optimization.</span>
<span class="sd">    :type uL: float</span>
<span class="sd">    :param bootstraps_uL: If uL was used in the original optimization, this should be</span>
<span class="sd">        provided. It is a list of the same length as the bootstrap replicates</span>
<span class="sd">        containing the sequence length-scaled mutation rates for the corresponding</span>
<span class="sd">        bootstrap SFS replicates, matching the index. If it it not given, uL is assumed</span>
<span class="sd">        to be equivalent across bootstrap sets, using the value provided in the uL</span>
<span class="sd">        keyword argument.</span>
<span class="sd">    :type bootstraps_uL: list</span>
<span class="sd">    :param log: Defaults to False. If True, we assume a log-normal distribution of</span>
<span class="sd">        parameters. Returned values are then the standard deviations of the *logs*</span>
<span class="sd">        of the parameter values, which can be interpreted as relative parameter</span>
<span class="sd">        uncertainties.</span>
<span class="sd">    :type log: bool</span>
<span class="sd">    :param eps: Fractional stepsize to use when taking finite-difference derivatives.</span>
<span class="sd">        Note that if eps*param is &lt; 1e-6, then the step size for that parameter</span>
<span class="sd">        will simply be eps, to avoid numerical issues with small parameter</span>
<span class="sd">        perturbations. Defaults to 0.01.</span>
<span class="sd">    :type eps: float</span>
<span class="sd">    :param method: Choose between either &quot;FIM&quot; (Fisher Information) or &quot;GIM&quot; (Godambe</span>
<span class="sd">        Information). Defaults to FIM. If GIM is chosen, bootstrap replicates must</span>
<span class="sd">        be provided.</span>
<span class="sd">    :type method: str</span>
<span class="sd">    :param fit_ancestral_misid: If we fit the ancestral misidentification in the</span>
<span class="sd">        original optimization, set to True.</span>
<span class="sd">    :type fit_ancestral_misid: bool</span>
<span class="sd">    :param misid_fit: If we fit the ancestral misidentification in the original</span>
<span class="sd">        optimization, provide the best fit value here.</span>
<span class="sd">    :type misid_fit: float</span>
<span class="sd">    :param verbose: If greater than zero, print the progress of iterations needed</span>
<span class="sd">        to compute uncertainties. Prints every {verbose} number of iterations.</span>
<span class="sd">    :type verbose: int</span>
<span class="sd">    :param output_stream: Default is sys.stdout, but can be changed using this</span>
<span class="sd">        option.</span>
<span class="sd">    :param output: If given, write the output as a tab-delimited table with</span>
<span class="sd">        parameter names, best-fit values, and standard errors as columns.</span>
<span class="sd">    :type output: str</span>
<span class="sd">    :param overwrite: If True, overwrite the output table of uncertainties.</span>
<span class="sd">    :type overwrite: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func_calls</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Get p0 and parameter information</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_get_demes_dict</span><span class="p">(</span><span class="n">deme_graph</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">_get_params_dict</span><span class="p">(</span><span class="n">inference_options</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data SFS must specify population IDs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pop_ids and sample_sizes have different lengths&quot;</span><span class="p">)</span>

    <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_set_up_params_and_bounds</span><span class="p">(</span>
        <span class="n">options</span><span class="p">,</span> <span class="n">builder</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_num_calls</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_expected_number_of_calls</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;Expected number of function calls: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exp_num_calls</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
        <span class="p">)</span>
        <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_ancestral_misid</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">misid_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;misid_fit cannot be None if fit_ancestral_misid is True&quot;</span><span class="p">)</span>
        <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;p_misid&quot;</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="p">[</span><span class="n">misid_fit</span><span class="p">]))</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lower_bound</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper_bound</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">sample_sizes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span>
    <span class="n">sampled_demes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span>

    <span class="c1"># Given scaled mutation rate (multinom = False), no extra parameters added</span>
    <span class="c1"># But if uL is None (multinom = True), add a scaling parameter (theta)</span>
    <span class="k">if</span> <span class="n">uL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">multinom</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">deme_graph</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">SFS</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="o">=</span><span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="o">=</span><span class="n">sample_sizes</span>
        <span class="p">)</span>
        <span class="n">uL</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">optimal_sfs_scaling</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">uL</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">multinom</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">func_ex</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        params is:</span>
<span class="sd">        opt_params + [misid_fit] (if fit_ancestral_misid) + [theta] (if uL is None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">nonlocal</span> <span class="n">builder</span>
        <span class="k">nonlocal</span> <span class="n">options</span>
        <span class="k">nonlocal</span> <span class="n">func_calls</span>
        <span class="n">func_calls</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># pull out uL and p_misid, if needed</span>
        <span class="k">if</span> <span class="n">multinom</span><span class="p">:</span>
            <span class="n">uL</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">demo_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">demo_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">fit_ancestral_misid</span><span class="p">:</span>
            <span class="n">p_misid</span> <span class="o">=</span> <span class="n">demo_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">demo_params</span> <span class="o">=</span> <span class="n">demo_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">demo_params</span> <span class="o">=</span> <span class="n">demo_params</span>
            <span class="n">p_misid</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># update the builder dict, then compute SFS</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">demo_params</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>

        <span class="n">sampled_demes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="n">sample_sizes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample_sizes</span>

        <span class="n">end_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">}</span>
        <span class="n">sample_times</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># check for any ancient samples, which have pop id</span>
        <span class="c1"># &quot;{deme.name}_sampled_{gen}_{frac_gen}&quot;</span>
        <span class="n">input_sampled_demes</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">deme</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">deme</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
                <span class="n">input_sampled_demes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_times</span><span class="p">[</span><span class="n">deme</span><span class="p">])</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">SFS</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">input_sampled_demes</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">uL</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">fit_ancestral_misid</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">flip_ancestral_misid</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">p_misid</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">func_calls</span> <span class="o">%</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># param_str = &quot;array([%s])&quot; % (&quot;, &quot;.join([&quot;%- 12g&quot; % v for v in params]))</span>
            <span class="c1"># output_stream.write(&quot;%-8i, %s%s&quot; % (func_calls, param_str, os.linesep))</span>
            <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Finished iteration </span><span class="si">{</span><span class="n">func_calls</span><span class="si">:</span><span class="s2"> &gt; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exp_num_calls</span><span class="p">))</span><span class="si">}}</span><span class="s2"> &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">exp_num_calls</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
            <span class="p">)</span>
            <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;FIM&quot;</span><span class="p">:</span>
        <span class="c1"># computing</span>
        <span class="k">if</span> <span class="n">bootstraps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;FIM method chosen but bootstrap replicates provided - &quot;</span>
                <span class="s2">&quot;Bootstraps will not be used&quot;</span>
            <span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">_get_godambe</span><span class="p">(</span><span class="n">func_ex</span><span class="p">,</span> <span class="p">[],</span> <span class="n">p0</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">uL</span><span class="o">=</span><span class="n">uL</span><span class="p">,</span> <span class="n">just_hess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">uncerts_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;GIM&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bootstraps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A list of SFS bootstrap replicates must be provided to use GIM method&quot;</span>
            <span class="p">)</span>
        <span class="n">GIM</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">cU</span> <span class="o">=</span> <span class="n">_get_godambe</span><span class="p">(</span>
            <span class="n">func_ex</span><span class="p">,</span>
            <span class="n">bootstraps</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">eps</span><span class="p">,</span>
            <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
            <span class="n">uL</span><span class="o">=</span><span class="n">uL</span><span class="p">,</span>
            <span class="n">all_boot_uL</span><span class="o">=</span><span class="n">bootstraps_uL</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">uncerts_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">GIM</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be either &#39;FIM&#39; or &#39;GIM&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_write_uncerts_output</span><span class="p">(</span>
            <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">uncerts_out</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">output_stream</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">uncerts_out</span></div>



<span class="c1">###############################################################</span>
<span class="c1"># Objective function and inference method for LD optimization #</span>
<span class="c1">###############################################################</span>


<div class="viewcode-block" id="compute_bin_stats">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.Inference.compute_bin_stats">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_bin_stats</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of per-base recombination rates defining recombination bin</span>
<span class="sd">    edges, computes expected LD statistics within each bin.</span>

<span class="sd">    :param g: A demes-formatted demographic model.</span>
<span class="sd">    :param sampled_demes: List of populations to sample.</span>
<span class="sd">    :param sample_types: Optional list of sample times for each population.</span>
<span class="sd">    :param rs: The list of bin edges, as an array of increasing values. Bins</span>
<span class="sd">        are defined using adjacent values, so that if ``rs`` has length n,</span>
<span class="sd">        there are n-1 bins.</span>
<span class="sd">    :return: An LDstats object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check for valid recombination rates</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rs must be a list of per-base recombination rates&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rs must have at least two recombination rates&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rs must be a list of increasing values&quot;</span><span class="p">)</span>
    <span class="c1"># rhos are computed internally in Demes.LD() using rs and the root deme initial Ne</span>
    <span class="n">y_edges</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">LD</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span>
    <span class="n">r_mids</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r_l</span> <span class="o">+</span> <span class="n">r_r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">r_l</span><span class="p">,</span> <span class="n">r_r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="n">y_mids</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">LD</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r_mids</span><span class="p">)</span>
    <span class="c1"># simpson&#39;s integration</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span>
        <span class="mi">1</span> <span class="o">/</span> <span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">y_mids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r_mids</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">LDstats</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">num_pops</span><span class="o">=</span><span class="n">y_edges</span><span class="o">.</span><span class="n">num_pops</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">sampled_demes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_object_func_LD</span><span class="p">(</span>
    <span class="n">params</span><span class="p">,</span>
    <span class="n">means</span><span class="p">,</span>
    <span class="n">varcovs</span><span class="p">,</span>
    <span class="n">builder</span><span class="p">,</span>
    <span class="n">options</span><span class="p">,</span>
    <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">statistics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># check bounds</span>
    <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">params</span> <span class="o">&lt;</span> <span class="n">lower_bound</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>
    <span class="k">if</span> <span class="n">upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">params</span> <span class="o">&gt;</span> <span class="n">upper_bound</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>
    <span class="c1"># check constraints</span>
    <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cons</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_out_of_bounds_val</span>

    <span class="k">global</span> <span class="n">_counter</span>
    <span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># update builder</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="c1"># build graph and compute LD stats</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
    <span class="n">sampled_demes</span> <span class="o">=</span> <span class="n">pop_ids</span>

    <span class="n">end_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">}</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># check for any ancient samples, which have pop id</span>
    <span class="c1"># &quot;{deme.name}_sampled_{gen}_{frac_gen}&quot;</span>
    <span class="n">input_sampled_demes</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">deme</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">deme</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
            <span class="n">input_sampled_demes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_times</span><span class="p">[</span><span class="n">deme</span><span class="p">])</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">compute_bin_stats</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">input_sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span>

    <span class="c1"># normalize statistics based on normalization population</span>
    <span class="n">norm_idx</span> <span class="o">=</span> <span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">normalization</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">sigmaD2</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">norm_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">statistics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">remove_normalized_lds</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">norm_idx</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">remove_nonpresent_statistics</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">statistics</span><span class="o">=</span><span class="n">statistics</span>
        <span class="p">)</span>

    <span class="n">LL</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">ll_over_bins</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">LL</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;God bad result: LL = nan&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_out_of_bounds_val</span>

    <span class="c1"># print outputs if verbose &gt; 0</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_counter</span> <span class="o">%</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">param_str</span> <span class="o">=</span> <span class="s2">&quot;array([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%- 12g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]))</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-8i</span><span class="s2">, </span><span class="si">%-12g</span><span class="s2">, </span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_counter</span><span class="p">,</span> <span class="n">LL</span><span class="p">,</span> <span class="n">param_str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">))</span>
        <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">LL</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_object_func_log_LD</span><span class="p">(</span><span class="n">log_params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objective function for optimization in log(params).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_object_func_LD</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_params</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="optimize_LD">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.Inference.optimize_LD">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">optimize_LD</span><span class="p">(</span>
    <span class="n">deme_graph</span><span class="p">,</span>
    <span class="n">inference_options</span><span class="p">,</span>
    <span class="n">means</span><span class="p">,</span>
    <span class="n">varcovs</span><span class="p">,</span>
    <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">statistics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">perturb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fmin&quot;</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
    <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize demography given a deme graph of initial and fixed parameters and</span>
<span class="sd">    inference options that specify which parameters to fit, and bounds or constraints</span>
<span class="sd">    on those parameters.</span>

<span class="sd">    :param deme_graph: A demographic model as a YAML file in ``demes`` format. This</span>
<span class="sd">        should be given as a string specifying the path and file name of the model.</span>
<span class="sd">    :param inference_options: A second YAML file, specifying the parameters to be</span>
<span class="sd">        optimized, parameter bounds, and constraints between parameters. Please see</span>
<span class="sd">        the documentation at</span>
<span class="sd">        https://momentsld.github.io/moments/extensions/demes.html#the-options-file</span>
<span class="sd">    :param means: The list of average normalized LD and H statistics, as produced by</span>
<span class="sd">         the parsing function ``moments.LD.Parsing.bootstrap_data(region_data)``.</span>
<span class="sd">    :param varcovs: The list of variance-covariance matrices for data within each</span>
<span class="sd">        recombination bin, as produced by the parsing function</span>
<span class="sd">        ``moments.LD.Parsing.bootstrap_data(region_data)``.</span>
<span class="sd">    :param pop_ids: The list of population names corresponding to the data.</span>
<span class="sd">    :param rs: A list of recombination bin edges, defining the recombination</span>
<span class="sd">        distance bins.</span>
<span class="sd">    :param statistics: A list of two lists, the first being the LD statistics</span>
<span class="sd">        present in the data, and the second the list of single-locus statistics</span>
<span class="sd">        present in the data.  **WARNING**: This option should *only* be used if</span>
<span class="sd">        there are missing or masked statistics in your data, aside from the</span>
<span class="sd">        normalizing pi2 statistic!  If there are no missing or removed</span>
<span class="sd">        statistics other than the normalization statistic, this option should</span>
<span class="sd">        not be used.</span>
<span class="sd">    :param normalization: The name of the population that was used to normalize</span>
<span class="sd">        the data. See documentation for examples specifying each of these arguments.</span>
<span class="sd">    :param maxiter: The maximum number of iterations to run optimization. Defaults</span>
<span class="sd">        to 1000. Note: maxiter does not seem to work with the Powell method! This</span>
<span class="sd">        appears to be a bug within scipy.optimize.</span>
<span class="sd">    :param perturb: The perturbation amount of the initial parameters. Defaults to</span>
<span class="sd">        zero, in which case we do not perturb the initial parameters in the input</span>
<span class="sd">        demes YAML. If perturb is greater than zero, the initial parameters in the input</span>
<span class="sd">        YAML are randomly perturbed by up to `perturb`-fold.</span>
<span class="sd">    :param verbose: The frequency to print updates to `output_stream` if greater than 1.</span>
<span class="sd">    :param log: If True, optimize over log of the parameters.</span>
<span class="sd">    :param method: The optimization method. Available methods are &quot;fmin&quot;, &quot;powell&quot;,</span>
<span class="sd">        and &quot;lbfgsb&quot;.</span>
<span class="sd">    :output_stream: Defaults to standard output. Can be given an open file stream</span>
<span class="sd">        instead or other output stream.</span>
<span class="sd">    :param output: If given, the filename for the output best-fit model YAML.</span>
<span class="sd">    :param overwrite: If True, overwrites any existing file with the same output</span>
<span class="sd">        name.</span>
<span class="sd">    :return: List of parameter names, optimized parameter values, and LL</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_get_demes_dict</span><span class="p">(</span><span class="n">deme_graph</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">_get_params_dict</span><span class="p">(</span><span class="n">inference_options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population IDs for sampled demes must be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normalization deme must be provided&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">normalization</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pop_ids</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normalizatino deme must be in pop_ids&quot;</span><span class="p">)</span>

    <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_set_up_params_and_bounds</span><span class="p">(</span>
        <span class="n">options</span><span class="p">,</span> <span class="n">builder</span>
    <span class="p">)</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="n">_set_up_constraints</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">perturb</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">perturb</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;perturb must be a non-negative number&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perturb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;perturb must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">perturb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">_perturb_params_constrained</span><span class="p">(</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">perturb</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">constraints</span>
        <span class="p">)</span>

    <span class="n">available_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fmin&quot;</span><span class="p">,</span> <span class="s2">&quot;powell&quot;</span><span class="p">,</span> <span class="s2">&quot;lbfgsb&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> not available,  must be one of &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">available_methods</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># rescale if log</span>
    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">obj_fun</span> <span class="o">=</span> <span class="n">_object_func_log_LD</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_fun</span> <span class="o">=</span> <span class="n">_object_func_LD</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">means</span><span class="p">,</span>
        <span class="n">varcovs</span><span class="p">,</span>
        <span class="n">builder</span><span class="p">,</span>
        <span class="n">options</span><span class="p">,</span>
        <span class="n">pop_ids</span><span class="p">,</span>
        <span class="n">rs</span><span class="p">,</span>
        <span class="n">statistics</span><span class="p">,</span>
        <span class="n">normalization</span><span class="p">,</span>
        <span class="n">lower_bound</span><span class="p">,</span>
        <span class="n">upper_bound</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
        <span class="n">output_stream</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># run optimization</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fmin&quot;</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span> <span class="o">=</span> <span class="n">outputs</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;powell&quot;</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin_powell</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="n">direc</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span> <span class="o">=</span> <span class="n">outputs</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lbfgsb&quot;</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin_l_bfgs_b</span><span class="p">(</span>
            <span class="n">obj_fun</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">iprint</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">pgtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">approx_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span><span class="p">,</span> <span class="n">info_dict</span> <span class="o">=</span> <span class="n">outputs</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">xopt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xopt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">xopt</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Did not write output YAML - </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2"> already exists. The model is &quot;</span>
                <span class="s2">&quot;printed below. To overwrite, set overwrite=True.&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
            <span class="p">)</span>
            <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">demes</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">xopt</span><span class="p">,</span> <span class="n">fopt</span></div>



<span class="c1">################################################################</span>
<span class="c1"># Methods for computing confidence intervals from LD inference #</span>
<span class="c1">################################################################</span>

<span class="c1"># Cache evaluations of the frequency spectrum inside our hessian/J</span>
<span class="c1"># evaluation function</span>
<span class="n">_ld_cache</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_godambe_LD</span><span class="p">(</span>
    <span class="n">func_ex</span><span class="p">,</span>
    <span class="n">all_boot</span><span class="p">,</span>
    <span class="n">p0</span><span class="p">,</span>
    <span class="n">means</span><span class="p">,</span>
    <span class="n">varcovs</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">just_hess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_ld_cache</span><span class="p">:</span>
            <span class="n">_ld_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_ex</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_ld_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">ll_over_bins</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log_func</span><span class="p">(</span><span class="n">logparams</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logparams</span><span class="p">),</span> <span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">)</span>

    <span class="c1"># First calculate the observed hessian</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="o">-</span><span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_hess</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="o">-</span><span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_hess</span><span class="p">(</span>
            <span class="n">log_func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">just_hess</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hess</span>

    <span class="c1"># Now the expectation of J over the bootstrap data</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)))</span>
    <span class="c1"># cU is a column vector</span>
    <span class="n">cU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">bs_ms</span> <span class="ow">in</span> <span class="n">all_boot</span><span class="p">:</span>
        <span class="c1"># boot = LDstats(boot)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">grad_temp</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_grad</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">bs_ms</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_temp</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_get_grad</span><span class="p">(</span>
                <span class="n">log_func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">bs_ms</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">J_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">grad_temp</span><span class="p">,</span> <span class="n">grad_temp</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span> <span class="o">+</span> <span class="n">J_temp</span>
        <span class="n">cU</span> <span class="o">=</span> <span class="n">cU</span> <span class="o">+</span> <span class="n">grad_temp</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">J</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boot</span><span class="p">)</span>
    <span class="n">cU</span> <span class="o">=</span> <span class="n">cU</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boot</span><span class="p">)</span>

    <span class="c1"># G = H*J^-1*H</span>
    <span class="n">J_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">godambe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span> <span class="n">J_inv</span><span class="p">),</span> <span class="n">hess</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">godambe</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">cU</span>


<div class="viewcode-block" id="uncerts_LD">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.Inference.uncerts_LD">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">uncerts_LD</span><span class="p">(</span>
    <span class="n">deme_graph</span><span class="p">,</span>
    <span class="n">inference_options</span><span class="p">,</span>
    <span class="n">means</span><span class="p">,</span>
    <span class="n">varcovs</span><span class="p">,</span>
    <span class="n">bootstraps</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">pop_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">statistics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;FIM&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
    <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute uncertainties for fitted parameters, using the output YAML from</span>
<span class="sd">    ``moments.Demes.Inference.optimize_LD()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func_calls</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Get p0 and parameter information</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">_get_demes_dict</span><span class="p">(</span><span class="n">deme_graph</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">_get_params_dict</span><span class="p">(</span><span class="n">inference_options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pop_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population IDs for sampled demes must be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normalization deme must be provided&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">normalization</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pop_ids</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normalizatino deme must be in pop_ids&quot;</span><span class="p">)</span>

    <span class="c1"># when statistics is None, we assume all statistics are present, and</span>
    <span class="c1"># we need to remove the normalizing statistic</span>
    <span class="k">if</span> <span class="n">statistics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">statistics</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Util</span><span class="o">.</span><span class="n">moment_names</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_ids</span><span class="p">))</span>
        <span class="p">(</span>
            <span class="n">statistics</span><span class="p">,</span>
            <span class="n">means</span><span class="p">,</span>
            <span class="n">varcovs</span><span class="p">,</span>
            <span class="n">bootstraps</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_remove_normalized_data</span><span class="p">(</span>
            <span class="n">statistics</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">normalization</span><span class="p">),</span> <span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">,</span> <span class="n">bootstraps</span>
        <span class="p">)</span>

    <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_set_up_params_and_bounds</span><span class="p">(</span>
        <span class="n">options</span><span class="p">,</span> <span class="n">builder</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_num_calls</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Godambe</span><span class="o">.</span><span class="n">_expected_number_of_calls</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;Expected number of function calls: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exp_num_calls</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
        <span class="p">)</span>
        <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">eval_time_1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">eval_time_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">func_ex</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">builder</span>
        <span class="k">nonlocal</span> <span class="n">options</span>
        <span class="k">nonlocal</span> <span class="n">func_calls</span>
        <span class="k">nonlocal</span> <span class="n">eval_time_1</span>
        <span class="k">nonlocal</span> <span class="n">eval_time_2</span>
        <span class="n">func_calls</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># update the builder dict, then compute LD</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">_update_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>

        <span class="n">sampled_demes</span> <span class="o">=</span> <span class="n">pop_ids</span>
        <span class="n">end_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">}</span>
        <span class="n">sample_times</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># check for any ancient samples, which have pop id</span>
        <span class="c1"># &quot;{deme.name}_sampled_{gen}_{frac_gen}&quot;</span>
        <span class="n">input_sampled_demes</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">deme</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">deme</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
                <span class="n">input_sampled_demes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_times</span><span class="p">[</span><span class="n">deme</span><span class="p">])</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">compute_bin_stats</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">input_sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="n">rs</span>
        <span class="p">)</span>

        <span class="c1"># normalize statistics based on normalization population</span>
        <span class="n">norm_idx</span> <span class="o">=</span> <span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">normalization</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">sigmaD2</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">norm_idx</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Inference</span><span class="o">.</span><span class="n">remove_nonpresent_statistics</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">statistics</span><span class="o">=</span><span class="n">statistics</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">func_calls</span> <span class="o">%</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">func_calls</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eval_time_1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">func_calls</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">eval_time_2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">eval_time</span> <span class="o">=</span> <span class="n">eval_time_2</span> <span class="o">-</span> <span class="n">eval_time_1</span>
                <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;One iteration took </span><span class="si">{</span><span class="n">eval_time</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> seconds, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected total time: </span><span class="si">{</span><span class="n">eval_time</span><span class="o">*</span><span class="n">exp_num_calls</span><span class="o">/</span><span class="mi">60</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> minutes&quot;</span>
                    <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">func_calls</span> <span class="o">%</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Finished iteration </span><span class="si">{</span><span class="n">func_calls</span><span class="si">:</span><span class="s2"> &gt; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exp_num_calls</span><span class="p">))</span><span class="si">}}</span><span class="s2"> &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">exp_num_calls</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
                <span class="p">)</span>
            <span class="n">moments</span><span class="o">.</span><span class="n">Misc</span><span class="o">.</span><span class="n">delayed_flush</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;FIM&quot;</span><span class="p">:</span>
        <span class="c1"># computing</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootstraps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;FIM method chosen but bootstrap replicates provided - &quot;</span>
                <span class="s2">&quot;Bootstraps will not be used&quot;</span>
            <span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">_get_godambe_LD</span><span class="p">(</span>
            <span class="n">func_ex</span><span class="p">,</span> <span class="p">[],</span> <span class="n">p0</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">varcovs</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">just_hess</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">uncerts_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;GIM&quot;</span><span class="p">:</span>
        <span class="c1"># check that data and boostraps match in sizes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootstraps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A list of LD bootstrap replicates must be provided to use GIM method&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="n">bootstraps</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;mismatch in number of bins between bootstrap and data means&quot;</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">means</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;mismatch in number of statistics between boostrap and &quot;</span>
                            <span class="s2">&quot;data means&quot;</span>
                        <span class="p">)</span>
        <span class="n">GIM</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">cU</span> <span class="o">=</span> <span class="n">_get_godambe_LD</span><span class="p">(</span>
            <span class="n">func_ex</span><span class="p">,</span>
            <span class="n">bootstraps</span><span class="p">,</span>
            <span class="n">p0</span><span class="p">,</span>
            <span class="n">means</span><span class="p">,</span>
            <span class="n">varcovs</span><span class="p">,</span>
            <span class="n">eps</span><span class="p">,</span>
            <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">uncerts_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">GIM</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be either &#39;FIM&#39; or &#39;GIM&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_write_uncerts_output</span><span class="p">(</span>
            <span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">uncerts_out</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">output_stream</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">uncerts_out</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Aaron Ragsdale.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>