

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>moments.Demes.Demes &mdash; moments 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            moments
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SFS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/sfs.html">The Site Frequency Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/parsing.html">Parsing the SFS from a VCF file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sfs/inference.html">SFS Inference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Linkage disequilibrium</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/ld.html">Multi-population LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/parsing.html">Parsing LD statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ld/inference.html">Inferring demography with LD</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/demes.html">Specifying models with <code class="docutils literal notranslate"><span class="pre">demes</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/two_locus.html">Two-locus frequency spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions/triallele.html">Triallele frequency spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/diversity.html">Demography and genetic diversity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/dfe.html">DFE inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/recombination.html">Linkage disequilibrium and recombination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/two_locus_selection.html">Selection at two loci</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data types and functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_moments.html">API for site frequency spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_ld.html">API for linkage disequilibrium</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api_demes.html">API for <code class="docutils literal notranslate"><span class="pre">demes</span></code> functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">moments</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">moments.Demes.Demes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for moments.Demes.Demes</h1><div class="highlight"><pre>
<span></span><span class="c1"># This script contains functions to compute the sample SFS from a demography</span>
<span class="c1"># defined using demes. Not ever deme graph will be supported, as moments can</span>
<span class="c1"># only handle integrating up to five populations, and cannot include selfing or</span>
<span class="c1"># cloning.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">demes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">moments</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">moments.LD</span>


<div class="viewcode-block" id="SFS">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.SFS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SFS</span><span class="p">(</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="n">sampled_demes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sample_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sample_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">unsampled_n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">reversible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">mutation_time_windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the SFS from a ``demes``-specified demographic model.</span>
<span class="sd">    ``demes`` is a package for specifying demographic models in a</span>
<span class="sd">    user-friendly, human-readable YAML format. This function</span>
<span class="sd">    automatically parses the demographic model and returns the SFS</span>
<span class="sd">    for the specified populations, sample sizes, and (optionally)</span>
<span class="sd">    sampling times.</span>

<span class="sd">    Selection and dominance can be specified as a single value for</span>
<span class="sd">    all populations, or on a per-deme basis using a dictionary</span>
<span class="sd">    mapping deme name to the coefficient (defaults can also be set</span>
<span class="sd">    if multiple demes have the same selection or dominance</span>
<span class="sd">    coefficient). The mutation rate can be given as either a</span>
<span class="sd">    per-base rate (possibly multiplied by the sequence length),</span>
<span class="sd">    or as a population size-scaled rate. If mutation rates are not</span>
<span class="sd">    given, the SFS is scaled by ``4*N_e``, so that multiplying the</span>
<span class="sd">    output SFS by ``u`` results in a properly scaled SFS.</span>

<span class="sd">    :param g: A ``demes`` DemeGraph from which to compute the SFS.</span>
<span class="sd">    :type g: :class:`demes.DemeGraph`</span>
<span class="sd">    :param sampled_demes: A list of deme IDs to take samples from. We can repeat</span>
<span class="sd">        demes, as long as the sampling of repeated deme IDs occurs at distinct</span>
<span class="sd">        times.</span>
<span class="sd">    :type sampled_demes: list of strings</span>
<span class="sd">    :param sample_sizes: A list of the same length as ``sampled_demes``,</span>
<span class="sd">        giving the sample sizes for each sampled deme.</span>
<span class="sd">    :type sample_sizes: list of ints</span>
<span class="sd">    :param sample_times: If None, assumes all sampling occurs at the end of the</span>
<span class="sd">        existence of the sampled deme. If there are</span>
<span class="sd">        ancient samples, ``sample_times`` must be a list of same length as</span>
<span class="sd">        ``sampled_demes``, giving the sampling times for each sampled</span>
<span class="sd">        deme. Sampling times are given in time units of the original deme graph,</span>
<span class="sd">        so might not necessarily be generations (e.g. if ``g.time_units`` is years)</span>
<span class="sd">    :type sample_times: list of scalars, optional</span>
<span class="sd">    :param unsampled_n: The default sample size of unsampled demes, which must be</span>
<span class="sd">        greater than or equal to 4.</span>
<span class="sd">    :type unsampled_n: int, optional</span>
<span class="sd">    :param gamma: The scaled selection coefficient(s), ``2*Ne*s``. Defaults to None,</span>
<span class="sd">        which implies neutrality. Can be given as a scalar value, in which case</span>
<span class="sd">        all populations have the same selection coefficient. Alternatively, can</span>
<span class="sd">        be given as a dictionary, with keys given as population names in the</span>
<span class="sd">        input Demes model. Any population missing from this dictionary will be</span>
<span class="sd">        assigned a selection coefficient of zero. A non-zero default selection</span>
<span class="sd">        coefficient can be provided, using the key ``_default``. See the Demes</span>
<span class="sd">        exension documentation for more details and examples.</span>
<span class="sd">    :type gamma: scalar or dict</span>
<span class="sd">    :param h: The dominance coefficient(s). Defaults to additivity (or genic</span>
<span class="sd">        selection). Can be given as a scalar value, in which case all populations</span>
<span class="sd">        have the same dominance coefficient. Alternatively, can be given as a</span>
<span class="sd">        dictionary, with keys given as population names in the input Demes model.</span>
<span class="sd">        Any population missing from this dictionary will be assigned a dominance</span>
<span class="sd">        coefficient of ``1/2`` (additivity). A different default dominance</span>
<span class="sd">        coefficient can be provided, using the key ``_default``. See the Demes</span>
<span class="sd">        exension documentation for more details and examples.</span>
<span class="sd">    :type h: scalar or dict</span>
<span class="sd">    :param theta: The scaled mutation rate(s), 4*Ne*u. When simulating under the</span>
<span class="sd">        infinite sites model (the default mutation model), ``theta`` should be given</span>
<span class="sd">        as a scalar value greater than zero. If it is not provided, it is computed</span>
<span class="sd">        using the input value of ``u`` as ``4*Ne*u``. If ``u`` is not provided, then</span>
<span class="sd">        the SFS is scaled by ``4*Ne``, and the user can recover a properly scaled SFS</span>
<span class="sd">        by multiplying it by ``u`` or ``u*L``. When simulating under the reversible</span>
<span class="sd">        mutation model (with ``reversible=True``), ``theta`` may be a list of length</span>
<span class="sd">        2 and both the forward and backward scaled mutation rates must be less</span>
<span class="sd">        than 1.</span>
<span class="sd">    :type theta: scalar or list of length 2</span>
<span class="sd">    :param u: The per-base mutation rate. When simulating under the infinite sites</span>
<span class="sd">        model (the default mutation model), ``u`` should be a scalar. When simulating</span>
<span class="sd">        under the reversible mutation model (with ``reversible=True``), ``u`` may</span>
<span class="sd">        be a list of length 2, and mutation rate(s) must be small enough so that</span>
<span class="sd">        the product of ``4*Ne*u`` is less than 1.</span>
<span class="sd">    :type u: scalar or list of length 2</span>
<span class="sd">    :param L: The effective sequence length, which may be used along with ``u`` to</span>
<span class="sd">        set the total mutation rate. Defaults to 1, and it must be 1 when using</span>
<span class="sd">        the reversible mutation model.</span>
<span class="sd">    :type L: scalar</span>
<span class="sd">    :param mutation_time_windows: A list of times, in ascending order,</span>
<span class="sd">        specifying time window breakpoints, over which we partition the SFS</span>
<span class="sd">        into the contributions of mutations originating within each window. It</span>
<span class="sd">        must start at zero and be monotonically increasing, and the final</span>
<span class="sd">        window spans from the last breakpoint until infinity. If specified, we</span>
<span class="sd">        return a list of :class:`moments.Spectrum` objects, one for each time</span>
<span class="sd">        window (so that number will be equal to</span>
<span class="sd">        ``len(mutation_time_windows)``). The order or spectra in this list will</span>
<span class="sd">        be in ascending order, so that the first element represents the SFS</span>
<span class="sd">        from mutation originating from time zero to the first non-zero specified</span>
<span class="sd">        time.</span>
<span class="sd">    :type mutation_time_windows: list of floats</span>
<span class="sd">    :return: A ``moments`` site frequency spectrum, with dimension equal to the</span>
<span class="sd">        length of ``sampled_demes``, and shape equal to ``sample_sizes`` plus one</span>
<span class="sd">        in each dimension, indexing the allele frequency in each deme from 0</span>
<span class="sd">        to n[i], where i is the deme index.</span>
<span class="sd">    :rtype: :class:`moments.Spectrum`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># could specify samples as a dict instead of sampled_demes and sample_sizes</span>
    <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampled_demes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sample_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;must specify either samples (as a dict mapping demes to sample sizes,&quot;</span>
                <span class="s2">&quot; or specify both sampled_demes and sample_times&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;samples must be a dict mapping demes to sample sizes&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sampled_demes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sample_sizes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;if samples is given as dict, cannot &quot;</span>
                <span class="s2">&quot;specify sampled_demes or sample_sizes&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if samples is given as dict, cannot specify sample times&quot;</span><span class="p">)</span>
        <span class="n">sampled_demes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">sample_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampled_demes and sample_sizes must be same length&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_times</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample_times must have same length as sampled_demes&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">deme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2"> is not in demography&quot;</span><span class="p">)</span>

    <span class="c1"># we need to copy these to new variable names</span>
    <span class="c1"># so they don&#39;t get updated during optimization</span>
    <span class="n">sampled_pops</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">)</span>
    <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sample_times</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unsampled_n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unsampled_n must be greater than 3&quot;</span><span class="p">)</span>

    <span class="n">sampled_deme_end_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_pops</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">deme_sample_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">sampled_deme_end_times</span>

    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">deme_sample_times</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sample time </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> is outside of deme </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&#39;s time span&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mutation_time_windows</span> <span class="o">=</span> <span class="n">_validate_mutation_time_windows</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)</span>
        <span class="n">extra_empty_spectra_needed</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># for any ancient samples, we need to add frozen branches</span>
    <span class="c1"># with this, all &quot;sample times&quot; are at time 0, and ancient sampled demes are frozen</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deme_sample_times</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># shift the times if min_t is larger than zero</span>
            <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">deme_sample_times</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mutation_time_windows</span> <span class="o">-=</span> <span class="n">min_t</span>
                <span class="n">mutation_time_windows</span><span class="p">[</span><span class="n">mutation_time_windows</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">num_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mutation_time_windows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_zeros</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">extra_empty_spectra_needed</span> <span class="o">=</span> <span class="n">num_zeros</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">mutation_time_windows</span> <span class="o">=</span> <span class="n">mutation_time_windows</span><span class="p">[</span><span class="n">num_zeros</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">,</span> <span class="n">list_of_frozen_demes</span> <span class="o">=</span> <span class="n">_augment_with_ancient_samples</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">,</span> <span class="n">deme_sample_times</span>
        <span class="p">)</span>
        <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">deme_sample_times</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_of_frozen_demes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">time_units</span> <span class="o">!=</span> <span class="s2">&quot;generations&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># rescale time units</span>
            <span class="n">mutation_time_windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">generation_time</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">_convert_to_generations</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deme_sample_times</span><span class="p">)</span>

    <span class="c1"># if any sample sizes are less than unsample_n, we increase and project after</span>
    <span class="n">sim_sample_sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sampled_pops</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">,</span> <span class="n">deme_sample_times</span><span class="p">):</span>
        <span class="n">sim_sample_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unsampled_n</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample time for </span><span class="si">{deme}</span><span class="s2"> must be within its time span&quot;</span><span class="p">)</span>

    <span class="c1"># get reference Ne from demes model</span>
    <span class="n">Ne</span> <span class="o">=</span> <span class="n">_get_root_Ne</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># if (unscaled) s is provided, convert into (scaled) gamma selection coefficients</span>
    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both gamma and s&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">s</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">gamma</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection coefficient must be a scalar value or dict&quot;</span><span class="p">)</span>

    <span class="c1"># check selection and dominance inputs</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;_default&quot;</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use `_default` as a deme name when selection is specified&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection coefficient must be a finite number&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gamma</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;_default&quot;</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deme </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> in gamma, but </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not in input graph&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection coefficient must be a scalar value or dict&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;_default&quot;</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deme </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> in h, but </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> not in input graph&quot;</span><span class="p">)</span>

    <span class="c1"># set up the mutation rates as needed</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Mutation rates must be a list of length 2 when using &quot;</span>
                    <span class="s2">&quot;the reversible mutation model&quot;</span>
                <span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of u or theta may be specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">theta</span> <span class="o">*=</span> <span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Mutation rates must be a list of length 2 when using &quot;</span>
                    <span class="s2">&quot;the reversible mutation model&quot;</span>
                <span class="p">)</span>
            <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">L</span>
            <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">L</span>

    <span class="c1"># if a scalar, must be positive; if list-like, must be length 2 and both positive</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reversible</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mutation rate must be a scalar value for the default ISM model&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mutation rate must be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reversible</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`mutation_time_windows` can only be specifice with ISM (`reversible=False`)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Sequence length L must be 1 when using the reversible mutation model&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta</span><span class="p">,</span> <span class="n">theta</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mutation rates must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mutation rates too large for reversible mutation model&quot;</span><span class="p">)</span>

    <span class="c1"># Get the list of demographic events from demes, which is a dictionary with</span>
    <span class="c1"># lists of splits, admixtures, mergers, branches, and pulses.</span>
    <span class="n">demes_demo_events</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">discrete_demographic_events</span><span class="p">()</span>

    <span class="c1"># Get the dict of events and event times that partition integration epochs, in</span>
    <span class="c1"># descending order. Events include demographic events, such as splits and</span>
    <span class="c1"># mergers and admixtures, as well as changes in population sizes or migration</span>
    <span class="c1"># rates that require instantaneous changes in the size function or migration matrix.</span>
    <span class="c1"># Also get the list of demes present in each epoch, as a dictionary with non-overlapping</span>
    <span class="c1"># adjoint epoch time intervals.</span>
    <span class="n">demo_events</span><span class="p">,</span> <span class="n">demes_present</span> <span class="o">=</span> <span class="n">_get_demographic_events</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">demes_demo_events</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">,</span> <span class="n">mutation_time_windows</span><span class="o">=</span><span class="n">mutation_time_windows</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">epoch_demes</span> <span class="ow">in</span> <span class="n">demes_present</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch_demes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Moments cannot integrate more than five demes at a time. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2"> has demes </span><span class="si">{</span><span class="n">epoch_demes</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Get the list of size functions, migration matrices, and frozen attributes from</span>
    <span class="c1"># the deme graph and event times, matching the integration times.</span>
    <span class="n">nu_funcs</span><span class="p">,</span> <span class="n">mig_mats</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">frozen_pops</span> <span class="o">=</span> <span class="n">_get_integration_parameters</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">,</span> <span class="n">list_of_frozen_demes</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span>
    <span class="p">)</span>

    <span class="c1"># Get the sample sizes within each deme, given sample sizes.</span>
    <span class="n">deme_sample_sizes</span> <span class="o">=</span> <span class="n">_get_deme_sample_sizes</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span>
        <span class="n">demo_events</span><span class="p">,</span>
        <span class="n">sampled_pops</span><span class="p">,</span>
        <span class="n">sim_sample_sizes</span><span class="p">,</span>
        <span class="n">demes_present</span><span class="p">,</span>
        <span class="n">unsampled_n</span><span class="o">=</span><span class="n">unsampled_n</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the SFS.</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">_compute_sfs</span><span class="p">(</span>
        <span class="n">demo_events</span><span class="p">,</span>
        <span class="n">demes_present</span><span class="p">,</span>
        <span class="n">deme_sample_sizes</span><span class="p">,</span>
        <span class="n">nu_funcs</span><span class="p">,</span>
        <span class="n">mig_mats</span><span class="p">,</span>
        <span class="n">Ts</span><span class="p">,</span>
        <span class="n">frozen_pops</span><span class="p">,</span>
        <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
        <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">reversible</span><span class="o">=</span><span class="n">reversible</span><span class="p">,</span>
        <span class="n">mutation_time_windows</span><span class="o">=</span><span class="n">mutation_time_windows</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">_reorder_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
            <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reorder_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sampled_pops</span><span class="p">)</span>

    <span class="c1"># project down to desired sample sizes, if needed</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
            <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">sample_sizes</span><span class="p">)</span>

    <span class="c1"># simplify pop id name of ancient sample at end time of that deme</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="k">for</span> <span class="n">fs_comp</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">assert</span> <span class="n">fs_comp</span><span class="o">.</span><span class="n">pop_ids</span> <span class="o">==</span> <span class="n">pids</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pids</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">pid</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">pid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_sampled_&quot;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sampled_deme_end_times</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
                        <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">extra_empty_spectra_needed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extra_empty_spectra_needed</span><span class="p">):</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">fs</span></div>



<div class="viewcode-block" id="LD">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.LD">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">LD</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute LD statistics from a ``demes``-specified demographic model.</span>
<span class="sd">    ``demes`` is a package for specifying demographic models in a</span>
<span class="sd">    user-friendly, human-readable YAML format. This function</span>
<span class="sd">    automatically parses the demographic model and returns LD statistics</span>
<span class="sd">    for the specified populations and (optionally) sampling times.</span>

<span class="sd">    No mutation or recombination rates are required. If recombination</span>
<span class="sd">    rates are omitted, only single-locus allelic diversity statistics</span>
<span class="sd">    will be computed. If mutation rates are omitted, that is, neither</span>
<span class="sd">    ``theta`` nor ``u`` are provided, the per-base mutation rate is set</span>
<span class="sd">    to 1. Thus, to recover the correctly scaled LD statistics, multiply</span>
<span class="sd">    the two-locus statistics by :math:`u^2` and the single-locus</span>
<span class="sd">    statistics by :math:`u`.</span>

<span class="sd">    :param g: A ``demes`` DemeGraph from which to compute the LD.</span>
<span class="sd">    :type g: :class:`demes.DemeGraph`</span>
<span class="sd">    :param sampled_demes: A list of deme IDs to take samples from. We can repeat</span>
<span class="sd">        demes, as long as the sampling of repeated deme IDs occurs at distinct</span>
<span class="sd">        times.</span>
<span class="sd">    :type sampled_demes: list of strings</span>
<span class="sd">    :param sample_times: If None, assumes all sampling occurs at the end of the</span>
<span class="sd">        existence of the sampled deme. If there are</span>
<span class="sd">        ancient samples, ``sample_times`` must be a list of same length as</span>
<span class="sd">        ``sampled_demes``, giving the sampling times for each sampled</span>
<span class="sd">        deme. Sampling times are given in time units of the original deme graph,</span>
<span class="sd">        so might not necessarily be generations (e.g. if ``g.time_units`` is years)</span>
<span class="sd">    :type sample_times: list of floats, optional</span>
<span class="sd">    :param rho: The population-size scaled recombination rate(s). Can be None, a</span>
<span class="sd">        non-negative float, or a list of values. Cannot be used with ``Ne``.</span>
<span class="sd">    :param theta: The population-size scaled mutation rate. Cannot be used</span>
<span class="sd">        with ``u``.</span>
<span class="sd">    :param r: The unscaled recombination rate(s). Can be None, a non-negative</span>
<span class="sd">        float, or a list of values. Recombination rates are scaled by ``Ne`` to</span>
<span class="sd">        get ``rho=4*Ne*u``, and ``Ne`` is determined by the root population size.</span>
<span class="sd">    :type r: scalar or list of scalars</span>
<span class="sd">    :param u: The raw per-base mutation rate. The reference effective population</span>
<span class="sd">        size ``Ne`` is determined from the demograhic model, after which</span>
<span class="sd">        ``theta`` is set to ``4*Ne*u``.</span>
<span class="sd">    :type u: scalar</span>
<span class="sd">    :return: A ``moments.LD`` LD statistics object, with number of populations equal</span>
<span class="sd">        to the length of ``sampled_demes``.</span>
<span class="sd">    :rtype: :class:`moments.LD.LDstats`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sample_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_times</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample_times must have same length as sampled_demes&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">sampled_demes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">deme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">deme</span><span class="si">}</span><span class="s2"> is not in demography&quot;</span><span class="p">)</span>

    <span class="c1"># we need to copy these to new names so they don&#39;t get updated during optimization</span>
    <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sample_times</span><span class="p">)</span>
    <span class="n">sampled_pops</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">)</span>

    <span class="n">sampled_deme_end_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sampled_pops</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">deme_sample_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">sampled_deme_end_times</span>

    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">deme_sample_times</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sample time </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> is outside of deme </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&#39;s time span&quot;</span><span class="p">)</span>

    <span class="c1"># for any ancient samples, we need to add frozen branches</span>
    <span class="c1"># with this, all &quot;sample times&quot; are at time 0, and ancient sampled demes are frozen</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deme_sample_times</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">,</span> <span class="n">list_of_frozen_demes</span> <span class="o">=</span> <span class="n">_augment_with_ancient_samples</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">,</span> <span class="n">deme_sample_times</span>
        <span class="p">)</span>
        <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">deme_sample_times</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_of_frozen_demes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">time_units</span> <span class="o">!=</span> <span class="s2">&quot;generations&quot;</span><span class="p">:</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="n">_convert_to_generations</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deme_sample_times</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sampled_pops</span><span class="p">,</span> <span class="n">deme_sample_times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample time for </span><span class="si">{deme}</span><span class="s2"> must be within its time span&quot;</span><span class="p">)</span>

    <span class="c1"># get the list of demographic events from demes, which is a dictionary with</span>
    <span class="c1"># lists of splits, admixtures, mergers, branches, and pulses</span>
    <span class="n">demes_demo_events</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">discrete_demographic_events</span><span class="p">()</span>

    <span class="c1"># get the dict of events and event times that partition integration epochs, in</span>
    <span class="c1"># descending order. events include demographic events, such as splits and</span>
    <span class="c1"># mergers and admixtures, as well as changes in population sizes or migration</span>
    <span class="c1"># rates that require instantaneous changes in the size function or migration matrix.</span>
    <span class="c1"># get the list of demes present in each epoch, as a dictionary with non-overlapping</span>
    <span class="c1"># adjoint epoch time intervals</span>
    <span class="n">demo_events</span><span class="p">,</span> <span class="n">demes_present</span> <span class="o">=</span> <span class="n">_get_demographic_events</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">demes_demo_events</span><span class="p">,</span> <span class="n">sampled_pops</span>
    <span class="p">)</span>

    <span class="c1"># get the list of size functions, migration matrices, and frozen attributes from</span>
    <span class="c1"># the deme graph and event times, matching the integration times</span>
    <span class="n">Ne</span> <span class="o">=</span> <span class="n">_get_root_Ne</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">nu_funcs</span><span class="p">,</span> <span class="n">mig_mats</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">frozen_pops</span> <span class="o">=</span> <span class="n">_get_integration_parameters</span><span class="p">(</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">,</span> <span class="n">list_of_frozen_demes</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span>
    <span class="p">)</span>

    <span class="n">selfing_rates</span> <span class="o">=</span> <span class="n">_get_selfing_rates</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">)</span>
    <span class="n">root_selfing_rate</span> <span class="o">=</span> <span class="n">_get_root_selfing_rate</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># set recombination and mutation rates</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only specify rho or r, but not both&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rho</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must be non-negative&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rho</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of theta and u may be specified&quot;</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">u</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mutation rate must be positive&quot;</span><span class="p">)</span>

    <span class="c1"># compute LD</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_compute_LD</span><span class="p">(</span>
        <span class="n">demo_events</span><span class="p">,</span>
        <span class="n">demes_present</span><span class="p">,</span>
        <span class="n">nu_funcs</span><span class="p">,</span>
        <span class="n">mig_mats</span><span class="p">,</span>
        <span class="n">Ts</span><span class="p">,</span>
        <span class="n">frozen_pops</span><span class="p">,</span>
        <span class="n">selfing_rates</span><span class="p">,</span>
        <span class="n">root_selfing_rate</span><span class="p">,</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">_reorder_LD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sampled_pops</span><span class="p">)</span>

    <span class="c1"># simplify pop id name if ancient sample at end time of that deme</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_sampled_&quot;</span> <span class="ow">in</span> <span class="n">pid</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">pid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_sampled_&quot;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sampled_deme_end_times</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">return</span> <span class="n">y</span></div>



<div class="viewcode-block" id="LDdecay">
<a class="viewcode-back" href="../../../api/api_demes.html#moments.Demes.LDdecay">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">LDdecay</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;simpson&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes average LD statistics within recombination bins. The input demographic</span>
<span class="sd">    model, sampled demes, and other arguments follow ``moments.Demes.LD()``. Here,</span>
<span class="sd">    either ``rho`` or ``r`` must be given as an array of at least length 2.</span>
<span class="sd">    Recombination bins are defined by adjacent values in the list of recombination</span>
<span class="sd">    distances, so that there are ``len(r) - 1`` sets of LD statistics in the output</span>
<span class="sd">    ``LDstats`` object.</span>

<span class="sd">    Possible numerical integration methods:</span>
<span class="sd">      - &quot;simpson&quot;, quadratic</span>
<span class="sd">      - &quot;trapezoid&quot;, linear</span>
<span class="sd">      - &quot;midpoint&quot;, zeroth order</span>

<span class="sd">    :param g: The input demographic model, loaded using ``demes``.</span>
<span class="sd">    :type g: :class:`demes.Graph`</span>
<span class="sd">    :param sampled_deme: List of deme names of demes in the input demographic</span>
<span class="sd">        model from which to draw samples from.</span>
<span class="sd">    :type sampled_deme: list of str</span>
<span class="sd">    :param rho: Monotonically increasing list of length two or more specifying</span>
<span class="sd">        recombination bin endpoints (in units of :math:`4 N_e r`). Only one of</span>
<span class="sd">        rho and r can be given.</span>
<span class="sd">    :type rho: list-like</span>
<span class="sd">    :param r: Monotonically increasing list of length two or more specifying</span>
<span class="sd">        recombination bin endpoints. Only one of rho and r can be given.</span>
<span class="sd">    :type r: list-like</span>
<span class="sd">    :param method: One of ``&quot;simpson&quot;, ``&quot;trapezoid&quot;``, or ``&quot;midpoint&quot;``.</span>
<span class="sd">    :type method: str</span>
<span class="sd">    :param sample_times: If None, assumes all sampling occurs at the end of the</span>
<span class="sd">        existence of the sampled deme. If there are</span>
<span class="sd">        ancient samples, ``sample_times`` must be a list of same length as</span>
<span class="sd">        ``sampled_demes``, giving the sampling times for each sampled</span>
<span class="sd">        deme. Sampling times are given in time units of the original deme graph,</span>
<span class="sd">        so might not necessarily be generations (e.g. if ``g.time_units`` is years)</span>
<span class="sd">    :type sample_times: list of floats, optional</span>
<span class="sd">    :param theta: The population-size scaled mutation rate. Cannot be used</span>
<span class="sd">        with ``u``.</span>
<span class="sd">    :type theta: scalar</span>
<span class="sd">    :param u: The raw per-base mutation rate. The reference effective population</span>
<span class="sd">        size ``Ne`` is determined from the demograhic model, after which</span>
<span class="sd">        ``theta`` is set to ``4*Ne*u``.</span>
<span class="sd">    :type u: scalar</span>
<span class="sd">    :return: A ``moments.LD`` LD statistics object, with number of populations equal</span>
<span class="sd">        to the length of ``sampled_demes``.</span>
<span class="sd">    :rtype: :class:`moments.LD.LDstats`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">rho</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must be monotinically increasing&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be monotinically increasing&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of rho and r can be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Exactly one of rho and r must be given as a list of length at least two&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must have length at least two&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must have length at least two&quot;</span><span class="p">)</span>

    <span class="n">possible_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;simpson&quot;</span><span class="p">,</span> <span class="s2">&quot;trapezoid&quot;</span><span class="p">,</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> is not in possible methods: </span><span class="si">{</span><span class="n">possible_methods</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;simpson&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rho</span><span class="p">,</span> <span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">rho</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;trapezoid&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="n">rho</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">rs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">rho</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_pass</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">rho_pass</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Additional kwargs that can be passed to LD() : sample_times=None, theta=None, u=None</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">LD</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r_pass</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho_pass</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;trapezoid&quot;</span><span class="p">:</span>
        <span class="n">ld_binned</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ld0</span><span class="p">,</span> <span class="n">ld1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">ld_binned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ld0</span> <span class="o">+</span> <span class="n">ld1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">LDstats</span><span class="p">(</span>
            <span class="n">ld_binned</span> <span class="o">+</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">H</span><span class="p">()],</span> <span class="n">num_pops</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">num_pops</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_new</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;simpson&quot;</span><span class="p">:</span>
        <span class="n">ld_binned</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">ld0</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">()[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">ldc</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">()[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ld1</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">LD</span><span class="p">()[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">ld_binned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ld0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ldc</span> <span class="o">+</span> <span class="n">ld1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">LDstats</span><span class="p">(</span>
            <span class="n">ld_binned</span> <span class="o">+</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">H</span><span class="p">()],</span> <span class="n">num_pops</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">num_pops</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_new</span></div>



<span class="c1">##</span>
<span class="c1">## general functions used by both SFS and LD</span>
<span class="c1">##</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_generations</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a deme graph that is not in time units of generations and converts</span>
<span class="sd">    times to generations, using the time units and generation times given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">time_units</span> <span class="o">==</span> <span class="s2">&quot;generations&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">sample_times</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sample_time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample_times</span><span class="p">):</span>
            <span class="n">sample_times</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_time</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">generation_time</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">in_generations</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">sample_times</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_augment_with_ancient_samples</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a demography object and new sampled demes where we add</span>
<span class="sd">    a branch event for the new sampled deme that is frozen.</span>

<span class="sd">    If all sample times are &gt; 0, we also slice the graph to remove the</span>
<span class="sd">    time interval that is more recent than the most recent sample time.</span>

<span class="sd">    New sampled, frozen demes are labeled &quot;{deme}_sampled_{sample_time}&quot;.</span>
<span class="sd">    Note that we cannot have multiple ancient sampling events at the same</span>
<span class="sd">    time for the same deme (for additional samples at the same time, increase</span>
<span class="sd">    the sample size).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Adjust the graph if all sample times are greater than 0</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_times</span><span class="p">)</span>
    <span class="n">g_new</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Demes</span><span class="o">.</span><span class="n">DemesUtil</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_times</span><span class="p">))</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">st</span> <span class="o">-</span> <span class="n">t</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">sample_times</span><span class="p">]</span>
    <span class="c1"># add frozen branches</span>
    <span class="n">frozen_demes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">demes</span><span class="o">.</span><span class="n">Builder</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">g_new</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sd_frozen</span> <span class="o">=</span> <span class="n">sd</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_sampled_</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># update names of sampled demes</span>
            <span class="n">sampled_demes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
            <span class="n">deme_sample_times</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">sd</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># add the frozen branch, as sample time is nonzero</span>
                <span class="n">frozen_demes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sd_frozen</span><span class="p">)</span>
                <span class="n">b</span><span class="o">.</span><span class="n">add_deme</span><span class="p">(</span>
                    <span class="n">sd_frozen</span><span class="p">,</span>
                    <span class="n">start_time</span><span class="o">=</span><span class="n">st</span><span class="p">,</span>
                    <span class="n">epochs</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="n">ancestors</span><span class="o">=</span><span class="p">[</span><span class="n">sd</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># change the name of the sampled branch, as we have all ancient samples</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sd</span><span class="p">:</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
                <span class="c1"># change migration and pulse demes involving this sampled deme</span>
                <span class="k">if</span> <span class="s2">&quot;migrations&quot;</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sd</span><span class="p">:</span>
                            <span class="n">m</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
                        <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;dest&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sd</span><span class="p">:</span>
                            <span class="n">m</span><span class="p">[</span><span class="s2">&quot;dest&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;migrations&quot;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
                <span class="k">if</span> <span class="s2">&quot;pulses&quot;</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">sd</span><span class="p">:</span>
                                <span class="n">p</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
                        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;dest&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sd</span><span class="p">:</span>
                            <span class="n">p</span><span class="p">[</span><span class="s2">&quot;dest&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_frozen</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">g_new</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">g_new</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">frozen_demes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_demographic_events</span><span class="p">(</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">demes_demo_events</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">mutation_time_windows</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns demographic events and present demes over each epoch.</span>
<span class="sd">    Epochs are divided by any demographic event.</span>

<span class="sd">    If mutation_time_windows is not None, we can also have &quot;events&quot; that</span>
<span class="sd">    are the breakpoints of those time windows, in which we turn on/off migration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first get set of all time dividers, from demographic events, migration</span>
    <span class="c1"># rate changes, deme epoch changes, and mutation_time_windows (if given)</span>
    <span class="n">break_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">deme</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
            <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
            <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">pulses</span><span class="p">:</span>
        <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pulse</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">migration</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">migrations</span><span class="p">:</span>
        <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">migration</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">migration</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">mutation_time_windows</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">break_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># get demes present for each integration epoch</span>
    <span class="n">integration_times</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">break_points</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">break_points</span><span class="p">))[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># find live demes in each epoch, starting with most ancient</span>
    <span class="n">demes_present</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="c1"># add demes as they appear from past to present to end of lists</span>
    <span class="n">deme_start_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
        <span class="n">deme_start_times</span><span class="p">[</span><span class="n">deme</span><span class="o">.</span><span class="n">start_time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deme_start_times</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Root deme must have start time as inf&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deme_start_times</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Deme graph can only have a single root&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">start_time</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">deme_start_times</span><span class="o">.</span><span class="n">keys</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">deme_id</span> <span class="ow">in</span> <span class="n">deme_start_times</span><span class="p">[</span><span class="n">start_time</span><span class="p">]:</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">integration_times</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deme_id</span><span class="p">)</span>

    <span class="c1"># Dictionary of demographic events, occurring in the order:</span>
    <span class="c1">#   branches, pulses, admixtures, mergers, splits.</span>
    <span class="c1"># Importantly, splits and mergers remove the parental populations, so if</span>
    <span class="c1"># there are events like branches or pulses that involve those parental</span>
    <span class="c1"># populations at the same time, they will not be present when we try to</span>
    <span class="c1"># apply those events, resulting in an error.</span>
    <span class="n">demo_events</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">demes_demo_events</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="n">branch</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">branch</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="n">demo_events</span><span class="p">[</span><span class="n">branch</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">demes_demo_events</span><span class="p">[</span><span class="s2">&quot;pulses&quot;</span><span class="p">]:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;pulse&quot;</span><span class="p">,</span> <span class="n">pulse</span><span class="o">.</span><span class="n">sources</span><span class="p">,</span> <span class="n">pulse</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="n">pulse</span><span class="o">.</span><span class="n">proportions</span><span class="p">)</span>
        <span class="n">demo_events</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">admix</span> <span class="ow">in</span> <span class="n">demes_demo_events</span><span class="p">[</span><span class="s2">&quot;admixtures&quot;</span><span class="p">]:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;admix&quot;</span><span class="p">,</span> <span class="n">admix</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">admix</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="n">admix</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="n">demo_events</span><span class="p">[</span><span class="n">admix</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">merge</span> <span class="ow">in</span> <span class="n">demes_demo_events</span><span class="p">[</span><span class="s2">&quot;mergers&quot;</span><span class="p">]:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;merge&quot;</span><span class="p">,</span> <span class="n">merge</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">merge</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="n">merge</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="n">demo_events</span><span class="p">[</span><span class="n">merge</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">demes_demo_events</span><span class="p">[</span><span class="s2">&quot;splits&quot;</span><span class="p">]:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">split</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">split</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">demo_events</span><span class="p">[</span><span class="n">split</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="c1"># if there are any unsampled demes that end before present and do not have</span>
    <span class="c1"># any descendent demes, we need to add marginalization events.</span>
    <span class="k">for</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">succs</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">successors</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">deme_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sampled_demes</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">succs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">g</span><span class="p">[</span><span class="n">succ</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;marginalize&quot;</span><span class="p">,</span> <span class="n">deme_id</span><span class="p">)</span>
            <span class="n">demo_events</span><span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="c1"># Mutation rate breakpoints get added as a special event, after all other</span>
    <span class="c1"># demographic events are handled for a given time.</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">mut_break_time</span> <span class="ow">in</span> <span class="n">mutation_time_windows</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;mut_break&quot;</span><span class="p">,)</span>
            <span class="n">demo_events</span><span class="p">[</span><span class="n">mut_break_time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">demo_events</span><span class="p">,</span> <span class="n">demes_present</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_root_Ne</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="c1"># get root population and set Ne to root size</span>
    <span class="k">for</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">predecessors</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">root_deme</span> <span class="o">=</span> <span class="n">deme_id</span>
            <span class="k">break</span>
    <span class="n">Ne</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">root_deme</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_size</span>
    <span class="k">return</span> <span class="n">Ne</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_integration_parameters</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">,</span> <span class="n">frozen_list</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of size functions, migration matrices, integration times,</span>
<span class="sd">    and lists frozen demes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nu_funcs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">integration_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">migration_matrices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frozen_demes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">Ne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Ne</span> <span class="o">=</span> <span class="n">_get_root_Ne</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Ne</span> <span class="o">!=</span> <span class="n">_get_root_Ne</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Input Ne is different from root population initial size, &quot;</span>
                <span class="s2">&quot;subsequent population size scaling may be incorrect&quot;</span>
            <span class="p">)</span>

    <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">live_demes</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">demes_present</span><span class="o">.</span><span class="n">items</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># get intergration time for interval</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Ne</span>
        <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">integration_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># get frozen attributes</span>
        <span class="n">freeze</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="ow">in</span> <span class="n">frozen_list</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">live_demes</span><span class="p">]</span>
        <span class="n">frozen_demes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freeze</span><span class="p">)</span>
        <span class="c1"># get nu_function or list of sizes (if all constant)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">live_demes</span><span class="p">:</span>
            <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_sizes_at_time</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">interval</span><span class="p">))</span>
        <span class="n">nu_func</span> <span class="o">=</span> <span class="n">_make_nu_func</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ne</span><span class="p">)</span>
        <span class="n">nu_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nu_func</span><span class="p">)</span>
        <span class="c1"># get migration matrix for interval</span>
        <span class="n">mig_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">live_demes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">live_demes</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">d_from</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">live_demes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">d_to</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">live_demes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">d_from</span> <span class="o">!=</span> <span class="n">d_to</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">_migration_rate_in_interval</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">d_from</span><span class="p">,</span> <span class="n">d_to</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
                    <span class="n">mig_mat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Ne</span> <span class="o">*</span> <span class="n">m</span>
        <span class="n">migration_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mig_mat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nu_funcs</span><span class="p">,</span> <span class="n">migration_matrices</span><span class="p">,</span> <span class="n">integration_times</span><span class="p">,</span> <span class="n">frozen_demes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_nu_func</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ne</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the sizes at start and end of time interval, and the size function for</span>
<span class="sd">    each deme, along with the integration time and reference Ne, return the</span>
<span class="sd">    size function that gets passed to the moments integration routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]):</span>
        <span class="c1"># all constant</span>
        <span class="n">nu_func</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">Ne</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nu_funcs_separated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nu_funcs_separated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">N0</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">N0</span> <span class="o">/</span> <span class="n">Ne</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">nu_funcs_separated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">N0</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NF</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">N0</span> <span class="o">/</span> <span class="n">Ne</span> <span class="o">+</span> <span class="n">t</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">NF</span> <span class="o">-</span> <span class="n">N0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ne</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
                <span class="n">nu_funcs_separated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">N0</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NF</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">N0</span>
                    <span class="o">/</span> <span class="n">Ne</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">NF</span> <span class="o">/</span> <span class="n">N0</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> not a valid size function&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">nu_func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">nu</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">nu_funcs_separated</span><span class="p">]</span>

        <span class="c1"># check that this is correct, or if we have to &quot;pin&quot; parameters</span>
    <span class="k">return</span> <span class="n">nu_func</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_sizes_at_time</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the start size, end size, and size function for given deme over the</span>
<span class="sd">    given time interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Can only intergrate constant, exponential, or linear size functions&quot;</span>
        <span class="p">)</span>
    <span class="n">size_function</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span>

    <span class="k">if</span> <span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
        <span class="n">start_size</span> <span class="o">=</span> <span class="n">end_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span>

    <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">start_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
            <span class="n">start_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_size</span> <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">time_span</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">time_span</span>
            <span class="n">start_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span> <span class="o">+</span> <span class="n">frac</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_size</span> <span class="o">-</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span> <span class="o">==</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">end_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">end_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
            <span class="n">end_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_size</span> <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">time_span</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">epoch</span><span class="o">.</span><span class="n">time_span</span>
            <span class="n">end_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span> <span class="o">+</span> <span class="n">frac</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_size</span> <span class="o">-</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">start_size</span><span class="p">,</span> <span class="n">end_size</span><span class="p">,</span> <span class="n">size_function</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_migration_rate_in_interval</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the migration rate from source to dest over the given time interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mig</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">migrations</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># if asymmetric migration</span>
            <span class="k">if</span> <span class="n">mig</span><span class="o">.</span><span class="n">source</span> <span class="o">==</span> <span class="n">source</span> <span class="ow">and</span> <span class="n">mig</span><span class="o">.</span><span class="n">dest</span> <span class="o">==</span> <span class="n">dest</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">mig</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">mig</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="n">mig</span><span class="o">.</span><span class="n">rate</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># symmetric migration</span>
            <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">mig</span><span class="o">.</span><span class="n">demes</span> <span class="ow">and</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">mig</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">mig</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">mig</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">time_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="n">mig</span><span class="o">.</span><span class="n">rate</span>
    <span class="k">return</span> <span class="n">rate</span>


<span class="c1">##</span>
<span class="c1">## Functions for SFS computation</span>
<span class="c1">##</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_mutation_time_windows</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">):</span>
    <span class="n">mutation_time_windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mutation time window must be at least [0]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mutation_time_windows</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mutation time window values must be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mutation time windows must start at zero&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mutation time window values cannot repeat&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mutation_time_windows</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">mutation_time_windows</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;mutation time windows values must be monotonically increasing&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">mutation_time_windows</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_deme_sample_sizes</span><span class="p">(</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">demo_events</span><span class="p">,</span> <span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">,</span> <span class="n">unsampled_n</span><span class="o">=</span><span class="mi">4</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns sample sizes within each deme that is present within each interval.</span>
<span class="sd">    Deme samples sizes can change if there are pulse or branching events, e.g.,</span>
<span class="sd">    but will be constant over the integration epochs.</span>
<span class="sd">    This works by climbing up the demography from most recent integration epoch to</span>
<span class="sd">    most distant. Unsampled leaf demes get size unsampled_ns, and others have size</span>
<span class="sd">    given by sample_sizes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">deme_ids</span> <span class="ow">in</span> <span class="n">demes_present</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">deme_ids</span><span class="p">]</span>

    <span class="c1"># initialize with sampled demes and unsampled, marginalized demes</span>
    <span class="k">for</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sampled_demes</span><span class="p">,</span> <span class="n">sample_sizes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
                <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">deme_id</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">n</span>

    <span class="c1"># Climb up the demographic events, taking into account pulses, branches, etc</span>
    <span class="c1"># when we add a new deme, determine base n from its successors (split, merge,</span>
    <span class="c1"># admixture), and propagate up. Similarly, propagate up other events that add</span>
    <span class="c1"># lineages to a branch (branches, pulses). Marginalize events add the deme</span>
    <span class="c1"># sample size with unsampled_n.</span>
    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">events</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">demo_events</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;marginalize&quot;</span><span class="p">:</span>
                <span class="n">deme_id</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># add unsampled deme</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                        <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                    <span class="p">):</span>
                        <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                            <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">deme_id</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">+=</span> <span class="n">unsampled_n</span>
            <span class="k">elif</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
                <span class="c1"># add the parental deme</span>
                <span class="n">deme_id</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
                        <span class="c1"># get child sizes at time of split</span>
                        <span class="n">children_ns</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="n">child</span><span class="p">:</span> <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span>
                        <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                        <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                    <span class="p">):</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                            <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                                <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">deme_id</span><span class="p">)</span>
                            <span class="p">]</span> <span class="o">+=</span> <span class="n">children_ns</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
                <span class="c1"># add child n to parent n for integration epochs above t</span>
                <span class="n">deme_id</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                        <span class="c1"># get child sizes at time of split</span>
                        <span class="n">child_ns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                        <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                        <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span>
                    <span class="p">):</span>
                        <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">deme_id</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">child_ns</span>
            <span class="k">elif</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;pulse&quot;</span><span class="p">:</span>
                <span class="c1"># figure out how much the admix_in_place needs from child to parent</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                            <span class="n">dest_size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                                <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
                            <span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                            <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                            <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span>
                        <span class="p">):</span>
                            <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                                <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                            <span class="p">]</span> <span class="o">+=</span> <span class="n">dest_size</span>
            <span class="k">elif</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
                <span class="c1"># each parent gets number of lineages in child</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                        <span class="n">child_size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                            <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                        <span class="p">):</span>
                            <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                                <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                            <span class="p">]</span> <span class="o">+=</span> <span class="n">child_size</span>
            <span class="k">elif</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;admix&quot;</span><span class="p">:</span>
                <span class="c1"># each parent gets num child lineages for all epochs above t</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                        <span class="n">child_size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                            <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                            <span class="ow">and</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span>
                        <span class="p">):</span>
                            <span class="n">ns</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span>
                                <span class="n">demes_present</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                            <span class="p">]</span> <span class="o">+=</span> <span class="n">child_size</span>
    <span class="k">return</span> <span class="n">ns</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_up_selection_dicts</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">gamma_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_default&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gamma_dict</span><span class="p">:</span>
            <span class="n">gamma_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_default&quot;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">h_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_default&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">h_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_default&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">h_dict</span><span class="p">:</span>
            <span class="n">h_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_default&quot;</span><span class="p">:</span> <span class="n">h</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">gamma_dict</span><span class="p">,</span> <span class="n">h_dict</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_sfs</span><span class="p">(</span>
    <span class="n">demo_events</span><span class="p">,</span>
    <span class="n">demes_present</span><span class="p">,</span>
    <span class="n">deme_sample_sizes</span><span class="p">,</span>
    <span class="n">nu_funcs</span><span class="p">,</span>
    <span class="n">migration_matrices</span><span class="p">,</span>
    <span class="n">integration_times</span><span class="p">,</span>
    <span class="n">frozen_demes</span><span class="p">,</span>
    <span class="n">theta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">reversible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mutation_time_windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrates using moments to find the SFS for given demo events, etc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reversible</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="c1"># theta is forward and backward rates, as list of length 2</span>
        <span class="n">theta_fd</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">theta_bd</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">theta_fd</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">theta_bd</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="n">mask_corners</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># theta is a scalar</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="n">mask_corners</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">integration_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">demes_present</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">root_deme</span> <span class="o">=</span> <span class="n">demes_present</span><span class="p">[</span><span class="n">integration_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># set up gamma and h as a dictionary covering all demes</span>
    <span class="n">gamma_dict</span><span class="p">,</span> <span class="n">h_dict</span> <span class="o">=</span> <span class="n">_set_up_selection_dicts</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="c1"># set up initial steady-state 1D SFS for ancestral deme</span>
    <span class="n">n0</span> <span class="o">=</span> <span class="n">deme_sample_sizes</span><span class="p">[</span><span class="n">integration_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gamma0</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root_deme</span> <span class="ow">in</span> <span class="n">gamma_dict</span><span class="p">:</span>
            <span class="n">gamma0</span> <span class="o">=</span> <span class="n">gamma_dict</span><span class="p">[</span><span class="n">root_deme</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma0</span> <span class="o">=</span> <span class="n">gamma_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">h0</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root_deme</span> <span class="ow">in</span> <span class="n">h_dict</span><span class="p">:</span>
            <span class="n">h0</span> <span class="o">=</span> <span class="n">h_dict</span><span class="p">[</span><span class="n">root_deme</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h0</span> <span class="o">=</span> <span class="n">h_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">reversible</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">moments</span><span class="o">.</span><span class="n">LinearSystem_1D</span><span class="o">.</span><span class="n">steady_state_1D</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">h0</span> <span class="o">!=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only use h=0.5 with reversible mutation model&quot;</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LinearSystem_1D</span><span class="o">.</span><span class="n">steady_state_1D_reversible</span><span class="p">(</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma0</span><span class="p">,</span> <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span> <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span>
        <span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">Spectrum</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pop_ids</span><span class="o">=</span><span class="p">[</span><span class="n">root_deme</span><span class="p">],</span> <span class="n">mask_corners</span><span class="o">=</span><span class="n">mask_corners</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fs</span><span class="p">]</span>

    <span class="c1"># for each set of demographic events and integration epochs, step through</span>
    <span class="c1"># integration, apply events, and then reorder populations to align with demes</span>
    <span class="c1"># present in the next integration epoch</span>
    <span class="k">for</span> <span class="n">T</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">frozen</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">integration_times</span><span class="p">,</span>
        <span class="n">nu_funcs</span><span class="p">,</span>
        <span class="n">migration_matrices</span><span class="p">,</span>
        <span class="n">frozen_demes</span><span class="p">,</span>
        <span class="n">integration_intervals</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gamma_int</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">gamma_dict</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="k">if</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">gamma_dict</span> <span class="k">else</span> <span class="n">gamma_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span>
                <span class="p">]</span>
                <span class="n">h_int</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">h_dict</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="k">if</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">h_dict</span> <span class="k">else</span> <span class="n">h_dict</span><span class="p">[</span><span class="s2">&quot;_default&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma_int</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">h_int</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">reversible</span><span class="p">:</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="n">nu</span><span class="p">,</span>
                    <span class="n">T</span><span class="p">,</span>
                    <span class="n">m</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
                    <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                    <span class="n">gamma</span><span class="o">=</span><span class="n">gamma_int</span><span class="p">,</span>
                    <span class="n">h</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span>
                    <span class="n">finite_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">theta_fd</span><span class="o">=</span><span class="n">theta_fd</span><span class="p">,</span>
                    <span class="n">theta_bd</span><span class="o">=</span><span class="n">theta_bd</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                        <span class="n">nu</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma_int</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
                        <span class="c1"># the first spectrum is the &quot;live&quot; one</span>
                        <span class="n">this_theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                            <span class="n">nu</span><span class="p">,</span>
                            <span class="n">T</span><span class="p">,</span>
                            <span class="n">m</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
                            <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
                            <span class="n">gamma</span><span class="o">=</span><span class="n">gamma_int</span><span class="p">,</span>
                            <span class="n">h</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span>
                            <span class="n">theta</span><span class="o">=</span><span class="n">this_theta</span><span class="p">,</span>
                        <span class="p">)</span>

        <span class="n">events</span> <span class="o">=</span> <span class="n">demo_events</span><span class="p">[</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mut_break&quot;</span><span class="p">:</span>
                <span class="c1"># if event is a time window break, apply it separately by extending the</span>
                <span class="c1"># list of spectra, by copying one of them and zeroing it out</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fs</span> <span class="o">=</span> <span class="n">_apply_event</span><span class="p">(</span>
                        <span class="n">fs</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deme_sample_sizes</span><span class="p">,</span> <span class="n">demes_present</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
                        <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_apply_event</span><span class="p">(</span>
                            <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">event</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deme_sample_sizes</span><span class="p">,</span> <span class="n">demes_present</span>
                        <span class="p">)</span>

        <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># rearrange to next order of demes</span>
            <span class="n">next_interval</span> <span class="o">=</span> <span class="n">integration_intervals</span><span class="p">[</span>
                <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">integration_intervals</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">next_deme_order</span> <span class="o">=</span> <span class="n">demes_present</span><span class="p">[</span><span class="n">next_interval</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># these may be able to be removed - from initial testing of method</span>
                <span class="k">assert</span> <span class="n">fs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_deme_order</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">d</span> <span class="ow">in</span> <span class="n">next_deme_order</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mutation_time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="n">_reorder_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">next_deme_order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)):</span>
                    <span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reorder_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">next_deme_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_apply_event</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">deme_sample_sizes</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">):</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;marginalize&quot;</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">marginalize</span><span class="p">([</span><span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># &quot;split&quot; into just one population (name change)</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># split into multiple children demes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot apply split that creates more than 5 demes&quot;</span><span class="p">)</span>
            <span class="c1"># get children deme sizes at time t</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">deme_sample_sizes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">split_sizes</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">deme_sample_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span>
                    <span class="p">]</span>
                    <span class="k">break</span>
            <span class="n">split_idx</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># children[0] is placed in split idx, the rest are at the end</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">_split_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">split_idx</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">split_sizes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
        <span class="c1"># use fs.branch function, new in 1.1.5</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">deme_sample_sizes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">branch_size</span> <span class="o">=</span> <span class="n">deme_sample_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                <span class="k">break</span>
        <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">,</span> <span class="n">branch_size</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;admix&quot;</span><span class="p">,</span> <span class="s2">&quot;merge&quot;</span><span class="p">]:</span>
        <span class="c1"># two or more populations merge, based on given proportions</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">proportions</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">deme_sample_sizes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">child_size</span> <span class="o">=</span> <span class="n">deme_sample_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">demes_present</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">_admix_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">child_size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;pulse&quot;</span><span class="p">:</span>
        <span class="c1"># admixture from one population to another, with some proportion</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">proportions</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">_pulse_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">proportions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Haven&#39;t implemented methods for event type </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_split_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">split_idx</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">split_sizes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the SFS into children with split_sizes, from the deme at split_idx.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">split_idx</span><span class="p">,</span>
            <span class="n">split_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">split_sizes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]),</span>
            <span class="n">split_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">new_ids</span><span class="o">=</span><span class="p">[</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
        <span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_admix_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">child_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Both merge and admixture events use this function, with the only difference that</span>
<span class="sd">    merge events remove the parental demes, while admixture events do not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># admix first two pops</span>
        <span class="n">fA</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fB</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fA</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fB</span><span class="p">)</span>
        <span class="n">idxA</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idxB</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span><span class="n">idxA</span><span class="p">,</span> <span class="n">idxB</span><span class="p">,</span> <span class="n">child_size</span><span class="p">,</span> <span class="n">fA</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># admix third pop</span>
        <span class="n">fAB</span> <span class="o">=</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fC</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fAB</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fC</span><span class="p">)</span>
        <span class="n">idxAB</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>  <span class="c1"># last pop, was added to end</span>
        <span class="n">idxC</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span><span class="n">idxAB</span><span class="p">,</span> <span class="n">idxC</span><span class="p">,</span> <span class="n">child_size</span><span class="p">,</span> <span class="n">fAB</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># admix 4th pop</span>
        <span class="n">fABC</span> <span class="o">=</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fD</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fABC</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fD</span><span class="p">)</span>
        <span class="n">idxABC</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">idxD</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span><span class="n">idxABC</span><span class="p">,</span> <span class="n">idxC</span><span class="p">,</span> <span class="n">child_size</span><span class="p">,</span> <span class="n">fABC</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># admix 5th pop</span>
        <span class="n">fABCD</span> <span class="o">=</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fE</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fABCD</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fE</span><span class="p">)</span>
        <span class="n">idxABCD</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">idxE</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span><span class="n">idxABCD</span><span class="p">,</span> <span class="n">idxE</span><span class="p">,</span> <span class="n">child_size</span><span class="p">,</span> <span class="n">fABCD</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pulse_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">proportions</span><span class="p">):</span>
    <span class="n">dest_idx</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">proportion</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">proportions</span><span class="p">)):</span>
        <span class="c1"># uses admix in place</span>
        <span class="n">source_idx</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="c1"># in the source deme, we keep that size minus the dest size</span>
        <span class="n">keep_from</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">source_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">fs</span><span class="o">.</span><span class="n">sample_sizes</span><span class="p">[</span><span class="n">dest_idx</span><span class="p">]</span>
        <span class="n">adjusted_proportion</span> <span class="o">=</span> <span class="n">proportion</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]))</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">pulse_migrate</span><span class="p">(</span><span class="n">source_idx</span><span class="p">,</span> <span class="n">dest_idx</span><span class="p">,</span> <span class="n">keep_from</span><span class="p">,</span> <span class="n">adjusted_proportion</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_reorder_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">next_deme_order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a SFS with given population order and returns a SFS with the order</span>
<span class="sd">    from ``next_deme_order``. Uses ``fs.swap_axes(idx1, idx2)`` sequentially</span>
<span class="sd">    through populations.</span>

<span class="sd">    :param next_deme_order: List of population IDs in the order of output SFS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">next_deme_order</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">next_deme_order</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fs.pop_ids and next_deme_order have mismatched IDs&quot;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">swap_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">next_deme_order</span><span class="p">):</span>
        <span class="n">pop_id</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pop_id</span> <span class="o">!=</span> <span class="n">swap_id</span><span class="p">:</span>
            <span class="n">swap_index</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">swap_id</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">swap_axes</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">swap_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="c1">##</span>
<span class="c1">## Functions for LD computation</span>
<span class="c1">##</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_selfing_rates</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of size functions, migration matrices, integration times,</span>
<span class="sd">    and lists frozen demes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">selfing_rates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">live_demes</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">demes_present</span><span class="o">.</span><span class="n">items</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># get selfing_rates for interval</span>
        <span class="n">interval_rates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">live_demes</span><span class="p">:</span>
            <span class="c1"># get the selfing rate for deme d in epoch that spans this interval</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">interval_rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
        <span class="n">selfing_rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval_rates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">selfing_rates</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_root_selfing_rate</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">deme_id</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">predecessors</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">root_deme</span> <span class="o">=</span> <span class="n">deme_id</span>
            <span class="k">break</span>
    <span class="n">root_selfing_rate</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">root_deme</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">selfing_rate</span>
    <span class="k">return</span> <span class="n">root_selfing_rate</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_LD</span><span class="p">(</span>
    <span class="n">demo_events</span><span class="p">,</span>
    <span class="n">demes_present</span><span class="p">,</span>
    <span class="n">nu_funcs</span><span class="p">,</span>
    <span class="n">migration_matrices</span><span class="p">,</span>
    <span class="n">integration_times</span><span class="p">,</span>
    <span class="n">frozen_demes</span><span class="p">,</span>
    <span class="n">selfing_rates</span><span class="p">,</span>
    <span class="n">root_selfing_rate</span><span class="p">,</span>
    <span class="n">rho</span><span class="p">,</span>
    <span class="n">theta</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">integration_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">demes_present</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># set up initial steady-state LD for ancestral deme</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">LDstats</span><span class="p">(</span>
        <span class="n">moments</span><span class="o">.</span><span class="n">LD</span><span class="o">.</span><span class="n">Numerics</span><span class="o">.</span><span class="n">steady_state</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">selfing_rate</span><span class="o">=</span><span class="p">[</span><span class="n">root_selfing_rate</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="n">num_pops</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pop_ids</span><span class="o">=</span><span class="n">demes_present</span><span class="p">[</span><span class="n">integration_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
    <span class="p">)</span>

    <span class="c1"># for each set of demographic events and integration epochs, step through</span>
    <span class="c1"># integration, apply events, and then reorder populations to align with demes</span>
    <span class="c1"># present in the next integration epoch</span>
    <span class="k">for</span> <span class="n">T</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">frozen</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">selfing_rate</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">integration_times</span><span class="p">,</span>
        <span class="n">nu_funcs</span><span class="p">,</span>
        <span class="n">migration_matrices</span><span class="p">,</span>
        <span class="n">frozen_demes</span><span class="p">,</span>
        <span class="n">integration_intervals</span><span class="p">,</span>
        <span class="n">selfing_rates</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selfing_rate</span><span class="p">]):</span>
            <span class="n">selfing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfing</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selfing_rate</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">nu</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">selfing</span><span class="o">=</span><span class="n">selfing</span>
            <span class="p">)</span>

        <span class="n">events</span> <span class="o">=</span> <span class="n">demo_events</span><span class="p">[</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_apply_LD_event</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">demes_present</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># rearrange to next order of demes</span>
            <span class="n">next_interval</span> <span class="o">=</span> <span class="n">integration_intervals</span><span class="p">[</span>
                <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">integration_intervals</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="c1"># marginalize populations that are not in next interval</span>
            <span class="c1"># possibly due to admixture event coinciding with deme end time</span>
            <span class="n">next_deme_order</span> <span class="o">=</span> <span class="n">demes_present</span><span class="p">[</span><span class="n">next_interval</span><span class="p">]</span>
            <span class="n">to_marginalize</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">next_deme_order</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">marg_deme</span> <span class="ow">in</span> <span class="n">to_marginalize</span><span class="p">:</span>
                <span class="n">event</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;marginalize&quot;</span><span class="p">,</span> <span class="n">marg_deme</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">_apply_LD_event</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">demes_present</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">num_pops</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_deme_order</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">d</span> <span class="ow">in</span> <span class="n">next_deme_order</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_reorder_LD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">next_deme_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_apply_LD_event</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">demes_present</span><span class="p">):</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;marginalize&quot;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">marginalize</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># &quot;split&quot; into just one population (name change)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">split_idx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># children[0] is placed in split idx, the rest are at the end</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_idx</span><span class="p">,</span> <span class="n">new_ids</span><span class="o">=</span><span class="p">[</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
        <span class="c1"># branch is a split, but keep the pop_id of parent</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">split_idx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_idx</span><span class="p">,</span> <span class="n">new_ids</span><span class="o">=</span><span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;admix&quot;</span><span class="p">,</span> <span class="s2">&quot;merge&quot;</span><span class="p">]:</span>
        <span class="c1"># two or more populations merge, based on given proportions</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">proportions</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># if e == &quot;admix&quot;:</span>
        <span class="c1">#    marg = False</span>
        <span class="c1"># elif e == &quot;merge&quot;:</span>
        <span class="c1">#    marg = True</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_admix_LD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">marginalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;pulse&quot;</span><span class="p">:</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dest_idx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">proportion</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">])):</span>
            <span class="c1"># admixture from one or more populations to another, with some proportion</span>
            <span class="n">source_idx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">adjusted_proportion</span> <span class="o">=</span> <span class="n">proportion</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pulse_migrate</span><span class="p">(</span><span class="n">source_idx</span><span class="p">,</span> <span class="n">dest_idx</span><span class="p">,</span> <span class="n">adjusted_proportion</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Haven&#39;t implemented methods for event type </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_admix_LD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">marginalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Both merge and admixture events use this function, with the only difference that</span>
<span class="sd">    merge events remove the parental demes, while admixture events do not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># admix first two pops</span>
        <span class="n">fA</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fB</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">proportions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">proportions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fA</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fB</span><span class="p">)</span>
        <span class="n">idxA</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idxB</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span><span class="n">idxA</span><span class="p">,</span> <span class="n">idxB</span><span class="p">,</span> <span class="n">fA</span><span class="p">,</span> <span class="n">new_id</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">proportions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportions</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">pulse_migrate</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">num_pops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">marginalize</span><span class="p">:</span>
        <span class="n">marg_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">marg_indexes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_reorder_LD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">next_deme_order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param y: LD stats object</span>
<span class="sd">    :param next_deme_order: List of population IDs in the order of output SFS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">### this function could be combined with ``_reorder_fs`` if swap_pops has</span>
    <span class="c1">### swap_axes as an alias...</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">next_deme_order</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">next_deme_order</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y.pop_ids and next_deme_order have mismatched IDs&quot;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">swap_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">next_deme_order</span><span class="p">):</span>
        <span class="n">pop_id</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pop_id</span> <span class="o">!=</span> <span class="n">swap_id</span><span class="p">:</span>
            <span class="n">swap_index</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">swap_id</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">swap_pops</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">swap_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Aaron Ragsdale.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>