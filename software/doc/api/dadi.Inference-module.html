<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>dadi.Inference</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://dadi.googlecode.com">dadi</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="dadi-module.html">Package&nbsp;dadi</a> ::
        Module&nbsp;Inference
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="dadi.Inference-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module Inference</h1><p class="nomargin-top"><span class="codelink"><a href="dadi.Inference-pysrc.html">source&nbsp;code</a></span></p>
<pre class="literalblock">

Comparison and optimization of model spectra to data.

</pre>

<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_object_func"></a><span class="summary-sig-name">_object_func</span>(<span class="summary-sig-arg">params</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ll_scale</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">output_stream</span>=<span class="summary-sig-default">sys.stdout</span>,
        <span class="summary-sig-arg">store_thetas</span>=<span class="summary-sig-default">False</span>)</span><br />
      Objective function for optimization.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#_object_func">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_object_func_log"></a><span class="summary-sig-name">_object_func_log</span>(<span class="summary-sig-arg">log_params</span>,
        <span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwargs</span>)</span><br />
      Objective function for optimization in log(params).</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#_object_func_log">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize_log" class="summary-sig-name">optimize_log</a>(<span class="summary-sig-arg">p0</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">epsilon</span>=<span class="summary-sig-default">0.001</span>,
        <span class="summary-sig-arg">gtol</span>=<span class="summary-sig-default">1e-05</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ll_scale</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize log(params) to fit model to data using the BFGS method.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize_log_lbfgsb" class="summary-sig-name">optimize_log_lbfgsb</a>(<span class="summary-sig-arg">p0</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">epsilon</span>=<span class="summary-sig-default">0.001</span>,
        <span class="summary-sig-arg">pgtol</span>=<span class="summary-sig-default">1e-05</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">100000.0</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ll_scale</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize log(params) to fit model to data using the L-BFGS-B method.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log_lbfgsb">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="minus_ll"></a><span class="summary-sig-name">minus_ll</span>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      The negative of the log-likelihood of the data given the model sfs.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#minus_ll">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#ll" class="summary-sig-name">ll</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      The log-likelihood of the data given the model sfs.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#ll">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#ll_per_bin" class="summary-sig-name">ll_per_bin</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">missing_model_cutoff</span>=<span class="summary-sig-default">1e-06</span>)</span><br />
      The Poisson log-likelihood of each entry in the data given the model sfs.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#ll_per_bin">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#ll_multinom_per_bin" class="summary-sig-name">ll_multinom_per_bin</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      Mutlinomial log-likelihood of each entry in the data given the model.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#ll_multinom_per_bin">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#ll_multinom" class="summary-sig-name">ll_multinom</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      Log-likelihood of the data given the model, with optimal rescaling.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#ll_multinom">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#minus_ll_multinom" class="summary-sig-name">minus_ll_multinom</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      The negative of the log-likelihood of the data given the model sfs.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#minus_ll_multinom">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#linear_Poisson_residual" class="summary-sig-name">linear_Poisson_residual</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the Poisson residuals, (model - data)/sqrt(model), of model and data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#linear_Poisson_residual">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#Anscombe_Poisson_residual" class="summary-sig-name">Anscombe_Poisson_residual</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the Anscombe Poisson residuals between model and data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#Anscombe_Poisson_residual">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimally_scaled_sfs" class="summary-sig-name">optimally_scaled_sfs</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      Optimially scale model sfs to data sfs.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimally_scaled_sfs">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimal_sfs_scaling" class="summary-sig-name">optimal_sfs_scaling</a>(<span class="summary-sig-arg">model</span>,
        <span class="summary-sig-arg">data</span>)</span><br />
      Optimal multiplicative scaling factor between model and data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimal_sfs_scaling">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize_log_fmin" class="summary-sig-name">optimize_log_fmin</a>(<span class="summary-sig-arg">p0</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize log(params) to fit model to data using Nelder-Mead.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log_fmin">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize" class="summary-sig-name">optimize</a>(<span class="summary-sig-arg">p0</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">epsilon</span>=<span class="summary-sig-default">0.001</span>,
        <span class="summary-sig-arg">gtol</span>=<span class="summary-sig-default">1e-05</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ll_scale</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize params to fit model to data using the BFGS method.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize_lbfgsb" class="summary-sig-name">optimize_lbfgsb</a>(<span class="summary-sig-arg">p0</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">lower_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">upper_bound</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">epsilon</span>=<span class="summary-sig-default">0.001</span>,
        <span class="summary-sig-arg">pgtol</span>=<span class="summary-sig-default">1e-05</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">100000.0</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ll_scale</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize log(params) to fit model to data using the L-BFGS-B method.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_lbfgsb">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_project_params_down"></a><span class="summary-sig-name">_project_params_down</span>(<span class="summary-sig-arg">pin</span>,
        <span class="summary-sig-arg">fixed_params</span>)</span><br />
      Eliminate fixed parameters from pin.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#_project_params_down">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_project_params_up"></a><span class="summary-sig-name">_project_params_up</span>(<span class="summary-sig-arg">pin</span>,
        <span class="summary-sig-arg">fixed_params</span>)</span><br />
      Fold fixed parameters into pin.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#_project_params_up">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="dadi.Inference-module.html#optimize_grid" class="summary-sig-name">optimize_grid</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">model_func</span>,
        <span class="summary-sig-arg">pts</span>,
        <span class="summary-sig-arg">grid</span>,
        <span class="summary-sig-arg">verbose</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">flush_delay</span>=<span class="summary-sig-default">0.5</span>,
        <span class="summary-sig-arg">multinom</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">full_output</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">func_args</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">func_kwargs</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="summary-sig-arg">fixed_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">output_file</span>=<span class="summary-sig-default">None</span>)</span><br />
      Optimize params to fit model to data using brute force search over a grid.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_grid">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logger"></a><span class="summary-name">logger</span> = <code title="logging.getLogger('Inference')">logging.getLogger('Inference')</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_theta_store"></a><span class="summary-name">_theta_store</span> = <code title="{}"><code class="variable-group">{</code><code class="variable-group">}</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_counter"></a><span class="summary-name">_counter</span> = <code title="0">0</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_out_of_bounds_val"></a><span class="summary-name">_out_of_bounds_val</span> = <code title="-100000000.0">-100000000.0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="index_exp"></a><span class="summary-name">index_exp</span> = <code title="numpy.index_exp">numpy.index_exp</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="'dadi'"><code class="variable-quote">'</code><code class="variable-string">dadi</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="optimize_log"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize_log</span>(<span class="sig-arg">p0</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">lower_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">upper_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">epsilon</span>=<span class="sig-default">0.001</span>,
        <span class="sig-arg">gtol</span>=<span class="sig-default">1e-05</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ll_scale</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize log(params) to fit model to data using the BFGS method.

This optimization method works well when we start reasonably close to the
optimum. It is best at burrowing down a single minimum.

Because this works in log(params), it cannot explore values of params &lt; 0.
It should also perform better when parameters range over scales.

p0: Initial parameters.
data: Spectrum with data.
model_function: Function to evaluate model spectrum. Should take arguments
                (params, (n1,n2...), pts)
lower_bound: Lower bound on parameter values. If not None, must be of same
             length as p0.
upper_bound: Upper bound on parameter values. If not None, must be of same
             length as p0.
verbose: If &gt; 0, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
epsilon: Step-size to use for finite-difference derivatives.
gtol: Convergence criterion for optimization. For more info, 
      see help(scipy.optimize.fmin_bfgs)
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
maxiter: Maximum iterations to run for.
full_output: If True, return full outputs as in described in 
             help(scipy.optimize.fmin_bfgs)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
           Using func_args.
           For example, you could define your model function as
           def func((p1,p2), ns, f1, f2, pts):
               ....
           If you wanted to fix f1=0.1 and f2=0.2 in the optimization, you
           would pass func_args = [0.1,0.2] (and ignore the fixed_params 
           argument).
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
              For example, suppose your model function is 
              def func((p1,f1,p2,f2), ns, pts):
                  ....
              If you wanted to fix f1=0.1 and f2=0.2 in the optimization, 
              you would pass fixed_params = [None,0.1,None,0.2] (and ignore
              the func_args argument).
ll_scale: The bfgs algorithm may fail if your initial log-likelihood is
          too large. (This appears to be a flaw in the scipy
          implementation.) To overcome this, pass ll_scale &gt; 1, which will
          simply reduce the magnitude of the log-likelihood. Once in a
          region of reasonable likelihood, you'll probably want to
          re-optimize with ll_scale=1.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimize_log_lbfgsb"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize_log_lbfgsb</span>(<span class="sig-arg">p0</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">lower_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">upper_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">epsilon</span>=<span class="sig-default">0.001</span>,
        <span class="sig-arg">pgtol</span>=<span class="sig-default">1e-05</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">100000.0</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ll_scale</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log_lbfgsb">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize log(params) to fit model to data using the L-BFGS-B method.

This optimization method works well when we start reasonably close to the
optimum. It is best at burrowing down a single minimum. This method is
better than optimize_log if the optimum lies at one or more of the
parameter bounds. However, if your optimum is not on the bounds, this
method may be much slower.

Because this works in log(params), it cannot explore values of params &lt; 0.
It should also perform better when parameters range over scales.

p0: Initial parameters.
data: Spectrum with data.
model_function: Function to evaluate model spectrum. Should take arguments
                (params, (n1,n2...), pts)
lower_bound: Lower bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
upper_bound: Upper bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
verbose: If &gt; 0, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
epsilon: Step-size to use for finite-difference derivatives.
pgtol: Convergence criterion for optimization. For more info, 
      see help(scipy.optimize.fmin_l_bfgs_b)
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
maxiter: Maximum algorithm iterations to run.
full_output: If True, return full outputs as in described in 
             help(scipy.optimize.fmin_bfgs)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
(See help(dadi.Inference.optimize_log for examples of func_args and 
 fixed_params usage.)
ll_scale: The bfgs algorithm may fail if your initial log-likelihood is
          too large. (This appears to be a flaw in the scipy
          implementation.) To overcome this, pass ll_scale &gt; 1, which will
          simply reduce the magnitude of the log-likelihood. Once in a
          region of reasonable likelihood, you'll probably want to
          re-optimize with ll_scale=1.

The L-BFGS-B method was developed by Ciyou Zhu, Richard Byrd, and Jorge
Nocedal. The algorithm is described in:
  * R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
    Constrained Optimization, (1995), SIAM Journal on Scientific and
    Statistical Computing , 16, 5, pp. 1190-1208.
  * C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
    FORTRAN routines for large scale bound constrained optimization (1997),
    ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550-560.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ll"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ll</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#ll">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

The log-likelihood of the data given the model sfs.

Evaluate the log-likelihood of the data given the model. This is based on
Poisson statistics, where the probability of observing k entries in a cell
given that the mean number is given by the model is 
P(k) = exp(-model) * model**k / k!

Note: If either the model or the data is a masked array, the return ll will
      ignore any elements that are masked in *either* the model or the data.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ll_per_bin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ll_per_bin</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">missing_model_cutoff</span>=<span class="sig-default">1e-06</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#ll_per_bin">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

The Poisson log-likelihood of each entry in the data given the model sfs.

missing_model_cutoff: Due to numerical issues, there may be entries in the
                      FS that cannot be stable calculated. If these entries
                      involve a fraction of the data larger than
                      missing_model_cutoff, a warning is printed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ll_multinom_per_bin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ll_multinom_per_bin</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#ll_multinom_per_bin">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Mutlinomial log-likelihood of each entry in the data given the model.

Scales the model sfs to have the optimal theta for comparison with the data.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ll_multinom"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ll_multinom</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#ll_multinom">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Log-likelihood of the data given the model, with optimal rescaling.

Evaluate the log-likelihood of the data given the model. This is based on
Poisson statistics, where the probability of observing k entries in a cell
given that the mean number is given by the model is 
P(k) = exp(-model) * model**k / k!

model is optimally scaled to maximize ll before calculation.

Note: If either the model or the data is a masked array, the return ll will
      ignore any elements that are masked in *either* the model or the data.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="minus_ll_multinom"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">minus_ll_multinom</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#minus_ll_multinom">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

The negative of the log-likelihood of the data given the model sfs.

Return a double that is -(log-likelihood)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="linear_Poisson_residual"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">linear_Poisson_residual</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#linear_Poisson_residual">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Poisson residuals, (model - data)/sqrt(model), of model and data.

mask sets the level in model below which the returned residual array is
masked. The default of 0 excludes values where the residuals are not 
defined.

In the limit that the mean of the Poisson distribution is large, these
residuals are normally distributed. (If the mean is small, the Anscombe
residuals are better.)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="Anscombe_Poisson_residual"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">Anscombe_Poisson_residual</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#Anscombe_Poisson_residual">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Anscombe Poisson residuals between model and data.

mask sets the level in model below which the returned residual array is
masked. This excludes very small values where the residuals are not normal.
1e-2 seems to be a good default for the NIEHS human data. (model = 1e-2,
data = 0, yields a residual of ~1.5.)

Residuals defined in this manner are more normally distributed than the
linear residuals when the mean is small. See this reference below for
justification: Pierce DA and Schafer DW, &quot;Residuals in generalized linear
models&quot; Journal of the American Statistical Association, 81(396)977-986
(1986).

Note that I tried implementing the &quot;adjusted deviance&quot; residuals, but they
always looked very biased for the cases where the data was 0.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimally_scaled_sfs"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimally_scaled_sfs</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimally_scaled_sfs">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimially scale model sfs to data sfs.

Returns a new scaled model sfs.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimal_sfs_scaling"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimal_sfs_scaling</span>(<span class="sig-arg">model</span>,
        <span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimal_sfs_scaling">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimal multiplicative scaling factor between model and data.

This scaling is based on only those entries that are masked in neither
model nor data.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimize_log_fmin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize_log_fmin</span>(<span class="sig-arg">p0</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">lower_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">upper_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_log_fmin">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize log(params) to fit model to data using Nelder-Mead. 

This optimization method may work better than BFGS when far from a
minimum. It is much slower, but more robust, because it doesn't use
gradient information.

Because this works in log(params), it cannot explore values of params &lt; 0.
It should also perform better when parameters range over large scales.

p0: Initial parameters.
data: Spectrum with data.
model_function: Function to evaluate model spectrum. Should take arguments
                (params, (n1,n2...), pts)
lower_bound: Lower bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
upper_bound: Upper bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
verbose: If True, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
maxiter: Maximum iterations to run for.
full_output: If True, return full outputs as in described in 
             help(scipy.optimize.fmin_bfgs)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
(See help(dadi.Inference.optimize_log for examples of func_args and 
 fixed_params usage.)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize</span>(<span class="sig-arg">p0</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">lower_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">upper_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">epsilon</span>=<span class="sig-default">0.001</span>,
        <span class="sig-arg">gtol</span>=<span class="sig-default">1e-05</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ll_scale</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize params to fit model to data using the BFGS method.

This optimization method works well when we start reasonably close to the
optimum. It is best at burrowing down a single minimum.

p0: Initial parameters.
data: Spectrum with data.
model_function: Function to evaluate model spectrum. Should take arguments
                (params, (n1,n2...), pts)
lower_bound: Lower bound on parameter values. If not None, must be of same
             length as p0.
upper_bound: Upper bound on parameter values. If not None, must be of same
             length as p0.
verbose: If &gt; 0, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
epsilon: Step-size to use for finite-difference derivatives.
gtol: Convergence criterion for optimization. For more info, 
      see help(scipy.optimize.fmin_bfgs)
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
maxiter: Maximum iterations to run for.
full_output: If True, return full outputs as in described in 
             help(scipy.optimize.fmin_bfgs)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
(See help(dadi.Inference.optimize_log for examples of func_args and 
 fixed_params usage.)
ll_scale: The bfgs algorithm may fail if your initial log-likelihood is
          too large. (This appears to be a flaw in the scipy
          implementation.) To overcome this, pass ll_scale &gt; 1, which will
          simply reduce the magnitude of the log-likelihood. Once in a
          region of reasonable likelihood, you'll probably want to
          re-optimize with ll_scale=1.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimize_lbfgsb"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize_lbfgsb</span>(<span class="sig-arg">p0</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">lower_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">upper_bound</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">epsilon</span>=<span class="sig-default">0.001</span>,
        <span class="sig-arg">pgtol</span>=<span class="sig-default">1e-05</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">100000.0</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ll_scale</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_lbfgsb">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize log(params) to fit model to data using the L-BFGS-B method.

This optimization method works well when we start reasonably close to the
optimum. It is best at burrowing down a single minimum. This method is
better than optimize_log if the optimum lies at one or more of the
parameter bounds. However, if your optimum is not on the bounds, this
method may be much slower.

p0: Initial parameters.
data: Spectrum with data.
model_function: Function to evaluate model spectrum. Should take arguments
                (params, (n1,n2...), pts)
lower_bound: Lower bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
upper_bound: Upper bound on parameter values. If not None, must be of same
             length as p0. A parameter can be declared unbound by assigning
             a bound of None.
verbose: If &gt; 0, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
epsilon: Step-size to use for finite-difference derivatives.
pgtol: Convergence criterion for optimization. For more info, 
      see help(scipy.optimize.fmin_l_bfgs_b)
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
maxiter: Maximum algorithm iterations evaluations to run.
full_output: If True, return full outputs as in described in 
             help(scipy.optimize.fmin_bfgs)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
(See help(dadi.Inference.optimize_log for examples of func_args and 
 fixed_params usage.)
ll_scale: The bfgs algorithm may fail if your initial log-likelihood is
          too large. (This appears to be a flaw in the scipy
          implementation.) To overcome this, pass ll_scale &gt; 1, which will
          simply reduce the magnitude of the log-likelihood. Once in a
          region of reasonable likelihood, you'll probably want to
          re-optimize with ll_scale=1.

The L-BFGS-B method was developed by Ciyou Zhu, Richard Byrd, and Jorge
Nocedal. The algorithm is described in:
  * R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
    Constrained Optimization, (1995), SIAM Journal on Scientific and
    Statistical Computing , 16, 5, pp. 1190-1208.
  * C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
    FORTRAN routines for large scale bound constrained optimization (1997),
    ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550-560.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="optimize_grid"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">optimize_grid</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">model_func</span>,
        <span class="sig-arg">pts</span>,
        <span class="sig-arg">grid</span>,
        <span class="sig-arg">verbose</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">flush_delay</span>=<span class="sig-default">0.5</span>,
        <span class="sig-arg">multinom</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">full_output</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">func_args</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">func_kwargs</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>,
        <span class="sig-arg">fixed_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">output_file</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="dadi.Inference-pysrc.html#optimize_grid">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Optimize params to fit model to data using brute force search over a grid.

data: Spectrum with data.
model_func: Function to evaluate model spectrum. Should take arguments
            (params, (n1,n2...), pts)
pts: Grid points list for evaluating likelihoods
grid: Grid of parameter values over which to evaluate likelihood. See
      below for specification instructions.
verbose: If &gt; 0, print optimization status every &lt;verbose&gt; steps.
output_file: Stream verbose output into this filename. If None, stream to
             standard out.
flush_delay: Standard output will be flushed once every &lt;flush_delay&gt;
             minutes. This is useful to avoid overloading I/O on clusters.
multinom: If True, do a multinomial fit where model is optimially scaled to
          data at each step. If False, assume theta is a parameter and do
          no scaling.
full_output: If True, return popt, llopt, grid, llout, thetas. Here popt is
             the best parameter set found and llopt is the corresponding
             (composite) log-likelihood. grid is the array of parameter
             values tried, llout is the corresponding log-likelihoods, and
             thetas is the corresponding thetas. Note that the grid includes
             only the parameters optimized over, and that the order of
             indices is such that grid[:,0,2] would be a set of parameters
             if two parameters were optimized over. (Note the : in the
             first index.)
func_args: Additional arguments to model_func. It is assumed that 
           model_func's first argument is an array of parameters to
           optimize, that its second argument is an array of sample sizes
           for the sfs, and that its last argument is the list of grid
           points to use in evaluation.
func_kwargs: Additional keyword arguments to model_func.
fixed_params: If not None, should be a list used to fix model parameters at
              particular values. For example, if the model parameters
              are (nu1,nu2,T,m), then fixed_params = [0.5,None,None,2]
              will hold nu1=0.5 and m=2. The optimizer will only change 
              T and m. Note that the bounds lists must include all
              parameters. Optimization will fail if the fixed values
              lie outside their bounds. A full-length p0 should be passed
              in; values corresponding to fixed parameters are ignored.
(See help(dadi.Inference.optimize_log for examples of func_args and 
 fixed_params usage.)

Search grids are specified using a dadi.Inference.index_exp object (which
is an alias for numpy.index_exp). The grid is specified by passing a range
of values for each parameter. For example, index_exp[0:1.1:0.3,
0.7:0.9:11j] will search over parameter 1 with values 0,0.3,0.6,0.9 and
over parameter 2 with 11 points between 0.7 and 0.9 (inclusive). (Notice
the 11j in the second parameter range specification.) Note that the grid
list should include only parameters that are optimized over, not fixed
parameter values.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://dadi.googlecode.com">dadi</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    <a href="epydoc-log.html">Generated by Epydoc
    3.0.1 on Fri Aug 14 15:39:34 2015</a>
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
