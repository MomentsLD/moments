#!/usr/bin/env python3

import sys
import random

import numpy as np
import moments


def dog_demog(params, ns):
    (
        N_anc_dog,  # (GL dog, CN dog) ancestral size
        N_wolf,  # arctic wolf size
        N_cn,  # CN dog size
        N_gl,  # GL dog pre-bottleneck size
        Nb_gl,  # GL dog bottleneck size
        Tsplit_gl_cn,  # time until (GL dog, CN dog) split
        Tb_gl,  # time until GL dog bottleneck starts
        T_present,  # time until the present
        m_wolf_gl,  # migration rate from wolf to GL dog
    ) = params
    (n_gl, n_wolf, n_cn) = ns  # ordered to match data

    sts = moments.LinearSystem_1D.steady_state_1D(sum(ns))
    fs = moments.Spectrum(sts)

    # split dogs off from wolf
    fs = moments.Manips.split_1D_to_2D(fs, n_cn + n_gl, n_wolf)

    fs.integrate([N_anc_dog, N_wolf], Tsplit_gl_cn)

    # split dogs
    fs = moments.Manips.split_2D_to_3D_1(fs, n_gl, n_cn)

    fs.integrate([N_gl, N_wolf, N_cn], Tb_gl)

    # bottleneck + migration until the present
    fs.integrate(
        [Nb_gl, N_wolf, N_cn],
        T_present,
        m=np.array([[0, 0, 0], [m_wolf_gl, 0, 0], [0, 0, 0]]),
    )

    return fs


def get_fs_from_angsd(
    sfs_file, pop_file, pop_ids=["GL_DOG", "CN_DOG", "ARCTIC_WOLF"], fold=False
):
    """
    Convert unfolded SFS generated by ANGSD into moments.Spectrum object.

    ANGSD should only be used to generate unfolded multidimensional spectra.
    If ancestral alleles are not available, alleles can be polarised from
    the reference sequence. In that case, the spectrum should be folded here.
    This retains more information than if one asks ANGSD to generate a folded
    spectrum.
    """
    pop_counts = {}
    with open(pop_file) as f:
        for line in f:
            pop_id = line.split()[1]
            n = pop_counts.get(pop_id, 0)
            pop_counts[pop_id] = n + 2
    ns = [pop_counts[pop_id] for pop_id in pop_ids]

    # get the SFS data
    with open(sfs_file) as f_data:
        data_line = f_data.readline()

    data = np.fromiter(map(float, data_line.split()), dtype=float)

    # check that the length of data matches the number of bins in the SFS
    assert np.prod([n + 1 for n in ns]) == len(data), "data does not match sample sizes"

    data = np.reshape(data, [n + 1 for n in ns])

    # turn into moments object
    fs = moments.Spectrum(data, mask_corners=True, pop_ids=pop_ids)

    if fold:
        fs = fs.fold()

    return fs, ns


def to_understandable_params(params, theta, mu, g):
    """
    Convert to absolute effective population sizes, and time in years.
    """
    Ne_ref = theta / (4 * mu)

    (
        N_anc_dog,
        N_wolf,
        N_cn,
        N_gl,
        Nb_gl,
        Tsplit_gl_cn,
        Tb_gl,
        T_present,
        m_wolf_gl,
    ) = params

    # Population sizes are in units of Ne.
    N_anc_dog *= Ne_ref
    N_wolf *= Ne_ref
    N_cn *= Ne_ref
    N_gl *= Ne_ref
    Nb_gl *= Ne_ref

    # Times are in units of 2*Ne generations.
    Tsplit_gl_cn *= g * 2 * Ne_ref
    Tb_gl *= g * 2 * Ne_ref
    T_present *= g * 2 * Ne_ref

    params = (
        N_anc_dog,
        N_wolf,
        N_cn,
        N_gl,
        Nb_gl,
        Tsplit_gl_cn,
        Tb_gl,
        T_present,
        m_wolf_gl,
    )

    return params, Ne_ref


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"usage: {sys.argv[0]} angsd-SFS.txt ind2pop.txt", file=sys.stderr)
        exit(1)

    sfs_file = sys.argv[1]
    pop_file = sys.argv[2]
    # angsd SFS was polarised by ref sequence, so fold it!
    data_fs, ns = get_fs_from_angsd(sfs_file, pop_file, fold=True)

    # mask singletons
    data_fs.mask[1, 0, 0] = True
    data_fs.mask[0, 1, 0] = True
    data_fs.mask[0, 0, 1] = True

    # Parameter bounds. I just copied the recommendations in moments' manual.
    lower = (1e-2, 1e-2, 1e-2, 1e-2, 1e-3, 1e-6, 1e-6, 1e-6, 1e-8)
    upper = (1e2, 1e2, 1e2, 1e2, 1e2, 10, 10, 10, 20)

    fixed = [None for _ in lower]
    fixed[0] = 1  # size of split pop to 1

    # Randomly initialise starting parameters.
    rng = random.Random(1234)
    p0 = [1, 1, 1, 1, 1, 0.1, 0.1, 0.1, 1.0]
    p0 = moments.Misc.perturb_params(p0, lower_bound=lower, upper_bound=upper, fold=1)
    #    p0 = [rng.uniform(lo, hi) for lo, hi in zip(lower, upper)]
    #    print(f"{p0=}")
    #    print(f"{np.log(p0)}")

    xopt = moments.Inference.optimize_log_powell(
        p0,
        data_fs,
        dog_demog,
        lower_bound=lower,
        upper_bound=upper,
        verbose=1,
        flush_delay=2 / 60,
        maxiter=5,
        fixed_params=fixed,
    )
    best_model_fs = dog_demog(xopt, ns)
    theta = moments.Inference.optimal_sfs_scaling(best_model_fs, data_fs)

    #    print(f"{theta=}")
    #    print(f"{xopt=})")

    # Generation time. Freedman et al. 2014; Fan et al. 2016
    g = 3
    # Per-generation mutation rate. Skoglund et al. 2015; Frantz et al. 2016
    mu = 4e-9

    p_opt, Ne_anc_canid = to_understandable_params(xopt, theta, mu, g)
#    print(f"{Ne_anc_canid=}")
#    print(f"{p_opt=}")
